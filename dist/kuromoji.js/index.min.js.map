{
  "version": 3,
  "sources": ["../src/_core/util/CreateTypedArray.ts", "../src/_core/util/DoubleArray.ts", "../src/_core/dict/ConnectionCosts.ts", "../src/_core/util/ByteBuffer.ts", "../src/_core/dict/TokenInfoDictionary.ts", "../src/_core/util/SurrogateAwareString.ts", "../src/_core/dict/CharacterClass.ts", "../src/_core/dict/InvokeDefinitionMap.ts", "../src/_core/dict/CharacterDefinition.ts", "../src/_core/dict/UnknownDictionary.ts", "../src/_core/dict/DynamicDictionaries.ts", "../src/_core/dict/builder/CharacterDefinitionBuilder.ts", "../src/_core/dict/builder/ConnectionCostsBuilder.ts", "../src/_core/dict/builder/DictionaryBuilder.ts", "../src/_core/util/IpadicFormatter.ts", "../src/_core/viterbi/ViterbiNode.ts", "../src/_core/viterbi/ViterbiLattice.ts", "../src/_core/viterbi/ViterbiBuilder.ts", "../src/_core/viterbi/ViterbiSearcher.ts", "../src/_core/Tokenizer.ts", "../src/kuromoji.js/loader/DictionaryLoader.ts", "../src/kuromoji.js/TokenizerBuilder.ts", "../src/kuromoji.js/kuromoji.ts"],
  "sourcesContent": [
    "export default (signed: boolean, bytes: number, size: number) => {\n    if (signed) {\n        switch (bytes) {\n            case 1:\n                return new Int8Array(size);\n            case 2:\n                return new Int16Array(size);\n            case 4:\n                return new Int32Array(size);\n            default:\n                throw new RangeError(`Invalid parameter: ${bytes}`);\n        }\n    }\n    switch (bytes) {\n        case 1:\n            return new Uint8Array(size);\n        case 2:\n            return new Uint16Array(size);\n        case 4:\n            return new Uint32Array(size);\n        default:\n            throw new RangeError(`Invalid parameter: ${bytes}`);\n    }\n};\n",
    "import createTypedArray from \"./CreateTypedArray\";\n\nconst TERM_CHAR = \"\\u0000\"; // terminal character\nconst TERM_CODE = 0; // terminal character code\nconst ROOT_ID = 0; // index of root node\nconst NOT_FOUND = -1; // traverse() returns if no nodes found\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\ntype ArrayBuffer = Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array;\n\ntype BaseCheck = {\n    signed: boolean;\n    bytes: number;\n    array: ArrayBuffer;\n};\n\nclass BufferController {\n    #first_unused_node: number;\n    #base: BaseCheck;\n    #check: BaseCheck;\n\n    constructor(initial_size = 1024) {\n        this.#first_unused_node = ROOT_ID + 1;\n\n        this.#base = {\n            signed: true,\n            bytes: 4,\n            array: createTypedArray(true, 4, initial_size),\n        };\n\n        this.#check = {\n            signed: true,\n            bytes: 4,\n            array: createTypedArray(true, 4, initial_size),\n        };\n\n        // Initialize root node\n        this.#base.array[ROOT_ID] = 1;\n        this.#check.array[ROOT_ID] = ROOT_ID;\n\n        // Initialize BASE and CHECK arrays\n        this.#initBase(this.#base.array, ROOT_ID + 1, this.#base.array.length);\n        this.#initCheck(this.#check.array, ROOT_ID + 1, this.#check.array.length);\n    }\n\n    #initBase(_base: ArrayBuffer, start: number, end: number) {\n        for (let i = start; i < end; i++) {\n            _base[i] = -i + 1;\n        }\n        if (0 < this.#check.array[this.#check.array.length - 1]) {\n            let last_used_id = this.#check.array.length - 2;\n            while (0 < this.#check.array[last_used_id]) {\n                last_used_id--;\n            }\n            _base[start] = -last_used_id;\n        }\n    }\n\n    #initCheck(_check: ArrayBuffer, start: number, end: number) {\n        for (let i = start; i < end; i++) {\n            _check[i] = -i - 1;\n        }\n    }\n\n    #realloc(min_size: number) {\n        const new_size = min_size * 2;\n        const base_new_array = createTypedArray(this.#base.signed, this.#base.bytes, new_size);\n        this.#initBase(base_new_array, this.#base.array.length, new_size);\n        base_new_array.set(this.#base.array);\n        this.#base.array = base_new_array;\n\n        const check_new_array = createTypedArray(this.#check.signed, this.#check.bytes, new_size);\n        this.#initCheck(check_new_array, this.#check.array.length, new_size);\n        check_new_array.set(this.#check.array);\n        this.#check.array = check_new_array;\n    }\n\n    getBaseBuffer() {\n        return this.#base.array;\n    }\n\n    getCheckBuffer() {\n        return this.#check.array;\n    }\n\n    loadBaseBuffer(base_buffer: ArrayBuffer) {\n        this.#base.array = base_buffer;\n        return this;\n    }\n\n    loadCheckBuffer(check_buffer: ArrayBuffer) {\n        this.#check.array = check_buffer;\n        return this;\n    }\n\n    size() {\n        return Math.max(this.#base.array.length, this.#check.array.length);\n    }\n\n    getBase(index: number) {\n        if (this.#base.array.length - 1 < index) {\n            return -index + 1;\n        }\n        return this.#base.array[index];\n    }\n\n    getCheck(index: number) {\n        if (this.#check.array.length - 1 < index) {\n            return -index - 1;\n        }\n        return this.#check.array[index];\n    }\n\n    setBase(index: number, base_value: number) {\n        if (this.#base.array.length - 1 < index) {\n            this.#realloc(index);\n        }\n        this.#base.array[index] = base_value;\n    }\n\n    setCheck(index: number, check_value: number) {\n        if (this.#check.array.length - 1 < index) {\n            this.#realloc(index);\n        }\n        this.#check.array[index] = check_value;\n    }\n\n    setFirstUnusedNode(index: number) {\n        this.#first_unused_node = index;\n    }\n\n    getFirstUnusedNode() {\n        return this.#first_unused_node;\n    }\n\n    shrink() {\n        let last_index = Math.max(this.#base.array.length, this.#check.array.length) - 1;\n        while (0 <= this.#check.array[last_index]) {\n            last_index--;\n        }\n        this.#base.array = this.#base.array.subarray(0, last_index + 2);\n        this.#check.array = this.#check.array.subarray(0, last_index + 2);\n    }\n\n    calc() {\n        let unused_count = 0;\n        const size = this.#check.array.length;\n        for (let i = 0; i < size; i++) {\n            if (this.#check.array[i] < 0) {\n                unused_count++;\n            }\n        }\n        return {\n            all: size,\n            unused: unused_count,\n            efficiency: (size - unused_count) / size,\n        };\n    }\n\n    dump() {\n        let dump_base = \"\";\n        let dump_check = \"\";\n\n        for (const data of this.#base.array) {\n            dump_base += ` ${data}`;\n        }\n        for (const data of this.#check.array) {\n            dump_check += ` ${data}`;\n        }\n\n        console.log(`base:${dump_base}`);\n        console.log(`check:${dump_check}`);\n\n        return `base:${dump_base} check:${dump_check}`;\n    }\n}\n\n/**\n * Factory method of double array\n */\nclass DoubleArrayBuilder {\n    #bufferController: BufferController;\n    #keys: { k: string | Uint8Array; v: number }[];\n    constructor(initial_size = 1024) {\n        this.#bufferController = new BufferController(initial_size); // BASE and CHECK\n        this.#keys = [];\n    }\n\n    /**\n     * Append a key to initialize set\n     * (This method should be called by dictionary ordered key)\n     *\n     * @param {String} key\n     * @param {Number} value Integer value from 0 to max signed integer number - 1\n     */\n    append(key: string, record: number) {\n        this.#keys.push({ k: key, v: record });\n        return this;\n    }\n\n    /**\n     * Build double array for given keys\n     *\n     * @param {Array} keys Array of keys. A key is a Object which has properties 'k', 'v'.\n     * 'k' is a key string, 'v' is a record assigned to that key.\n     * @return {DoubleArray} Compiled double array\n     */\n    build(keys: { k: string | Uint8Array; v: number }[] = this.#keys, sorted = false) {\n        if (keys == null) {\n            return new DoubleArray(this.#bufferController);\n        }\n        // Convert key string to ArrayBuffer\n        const buff_keys: { k: Uint8Array; v: number }[] | null = keys.map((k) => {\n            return {\n                k: encoder.encode(k.k + TERM_CHAR),\n                v: k.v,\n            };\n        });\n\n        // Sort keys by byte order\n        if (sorted) {\n            this.#keys = buff_keys;\n        } else {\n            this.#keys = buff_keys.sort((k1, k2) => {\n                const b1 = k1.k;\n                const b2 = k2.k;\n                const min_length = Math.min(b1.length, b2.length);\n                for (let pos = 0; pos < min_length; pos++) {\n                    if (b1[pos] === b2[pos]) {\n                        continue;\n                    }\n                    return b1[pos] - b2[pos];\n                }\n                return b1.length - b2.length;\n            });\n        }\n\n        this.#_build(ROOT_ID, 0, 0, this.#keys.length);\n        return new DoubleArray(this.#bufferController);\n    }\n\n    /**\n     * Append nodes to BASE and CHECK array recursively\n     */\n    #_build(parent_index: number, position: number, start: number, length: number) {\n        const children_info = this.#getChildrenInfo(position, start, length);\n        const _base = this.#findAllocatableBase(children_info);\n\n        this.#setBufferController(parent_index, children_info, _base);\n\n        for (let i = 0; i < children_info.length; i = i + 3) {\n            const child_code = children_info[i];\n            if (child_code === TERM_CODE) {\n                continue;\n            }\n            const child_start = children_info[i + 1];\n            const child_len = children_info[i + 2];\n            const child_index = _base + child_code;\n            this.#_build(child_index, position + 1, child_start, child_len);\n        }\n    }\n\n    #getChildrenInfo(position: number, start: number, length: number) {\n        let current_char = this.#keys[start].k[position];\n        let children_info = new Int32Array(length * 3);\n        let i = 0;\n        children_info[i++] = Number.parseInt(`${current_char}`); // char (current)\n        children_info[i++] = start; // start index (current)\n\n        let next_pos = start;\n        let start_pos = start;\n        for (; next_pos < start + length; next_pos++) {\n            const next_char = this.#keys[next_pos].k[position];\n            if (current_char !== next_char) {\n                children_info[i++] = next_pos - start_pos; // length (current)\n\n                children_info[i++] = Number.parseInt(`${next_char}`); // char (next)\n                children_info[i++] = next_pos; // start index (next)\n                current_char = next_char;\n                start_pos = next_pos;\n            }\n        }\n        children_info[i++] = next_pos - start_pos;\n        children_info = children_info.subarray(0, i);\n\n        return children_info;\n    }\n\n    #setBufferController(parent_id: number, children_info: Int32Array, _base: number) {\n        const bufferController = this.#bufferController;\n        bufferController.setBase(parent_id, _base); // Update BASE of parent node\n        for (let i = 0; i < children_info.length; i = i + 3) {\n            const code = children_info[i];\n            const child_id = _base + code;\n\n            // Update linked list of unused nodes\n\n            // Assertion\n            // if (child_id < 0) {\n            //     throw 'assertion error: child_id is negative'\n            // }\n\n            const prev_unused_id = -bufferController.getBase(child_id);\n            const next_unused_id = -bufferController.getCheck(child_id);\n            // if (prev_unused_id < 0) {\n            //     throw 'assertion error: setBC'\n            // }\n            // if (next_unused_id < 0) {\n            //     throw 'assertion error: setBC'\n            // }\n            if (child_id !== bufferController.getFirstUnusedNode()) {\n                bufferController.setCheck(prev_unused_id, -next_unused_id);\n            } else {\n                // Update first_unused_node\n                bufferController.setFirstUnusedNode(next_unused_id);\n            }\n            bufferController.setBase(next_unused_id, -prev_unused_id);\n\n            const check = parent_id; // CHECK is parent node index\n            bufferController.setCheck(child_id, check); // Update CHECK of child node\n\n            // Update record\n            if (code === TERM_CODE) {\n                const start_pos = children_info[i + 1];\n                // var len = children_info[i + 2];\n                // if (len != 1) {\n                //     throw 'assertion error: there are multiple terminal nodes. len:' + len;\n                // }\n                let value = this.#keys[start_pos].v;\n\n                if (value == null) {\n                    value = 0;\n                }\n\n                const base = -value - 1; // BASE is inverted record value\n                bufferController.setBase(child_id, base); // Update BASE of child(leaf) node\n            }\n        }\n    }\n\n    /**\n     * Find BASE value that all children are allocatable in double array's region\n     */\n    #findAllocatableBase(children_info: Int32Array) {\n        const bufferController = this.#bufferController;\n\n        // Assertion: keys are sorted by byte order\n        // var c = -1;\n        // for (var i = 0; i < children_info.length; i = i + 3) {\n        //     if (children_info[i] < c) {\n        //         throw 'assertion error: not sort key'\n        //     }\n        //     c = children_info[i];\n        // }\n\n        // iterate linked list of unused nodes\n        let _base: number;\n        let curr = bufferController.getFirstUnusedNode(); // current index\n        // if (curr < 0) {\n        //     throw 'assertion error: getFirstUnusedNode returns negative value'\n        // }\n\n        while (true) {\n            _base = curr - children_info[0];\n\n            if (_base < 0) {\n                curr = -bufferController.getCheck(curr); // next\n\n                // if (curr < 0) {\n                //     throw 'assertion error: getCheck returns negative value'\n                // }\n\n                continue;\n            }\n\n            let empty_area_found = true;\n            for (let i = 0; i < children_info.length; i = i + 3) {\n                const code = children_info[i];\n                const candidate_id = _base + code;\n\n                if (!this.#isUnusedNode(candidate_id)) {\n                    // candidate_id is used node\n                    // next\n                    curr = -bufferController.getCheck(curr);\n                    // if (curr < 0) {\n                    //     throw 'assertion error: getCheck returns negative value'\n                    // }\n\n                    empty_area_found = false;\n                    break;\n                }\n            }\n            if (empty_area_found) {\n                // Area is free\n                return _base;\n            }\n        }\n    }\n\n    /**\n     * Check this double array index is unused or not\n     */\n    #isUnusedNode(index: number) {\n        const bufferController = this.#bufferController;\n        const check = bufferController.getCheck(index);\n\n        // if (index < 0) {\n        //     throw 'assertion error: isUnusedNode index:' + index;\n        // }\n\n        if (index === ROOT_ID) {\n            // root node\n            return false;\n        }\n        if (check < 0) {\n            // unused\n            return true;\n        }\n\n        // used node (incl. leaf)\n        return false;\n    }\n}\n\n/**\n * Factory method of double array\n */\nclass DoubleArray {\n    #bufferController: BufferController;\n    constructor(bufferController: BufferController) {\n        this.#bufferController = bufferController; // BASE and CHECK\n        this.#bufferController.shrink();\n    }\n\n    /**\n     * Look up a given key in this trie\n     *\n     * @param {String} key\n     * @return {Boolean} True if this trie contains a given key\n     */\n    contain(_key: string) {\n        let key = _key;\n        const bufferController = this.#bufferController;\n        key += TERM_CHAR;\n        const buffer = encoder.encode(key);\n        let parent = ROOT_ID;\n        let child = NOT_FOUND;\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n\n            child = this.#traverse(parent, code);\n            if (child === NOT_FOUND) {\n                return false;\n            }\n\n            if (bufferController.getBase(child) <= 0) {\n                // leaf node\n                return true;\n            }\n            // not leaf\n            parent = child;\n        }\n        return false;\n    }\n\n    /**\n     * Look up a given key in this trie\n     *\n     * @param {String} key\n     * @return {Number} Record value assgned to this key, -1 if this key does not contain\n     */\n    lookup(_key: string) {\n        let key = _key;\n        key += TERM_CHAR;\n        const buffer = encoder.encode(key);\n        let parent = ROOT_ID;\n        let child = NOT_FOUND;\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            child = this.#traverse(parent, code);\n            if (child === NOT_FOUND) {\n                return NOT_FOUND;\n            }\n            parent = child;\n        }\n        const base = this.#bufferController.getBase(child);\n        if (base <= 0) {\n            // leaf node\n            return -base - 1;\n        }\n        // not leaf\n        return NOT_FOUND;\n    }\n\n    /**\n     * Common prefix search\n     *\n     * @param {String} key\n     * @return {Array} Each result object has 'k' and 'v' (key and record,\n     * respectively) properties assigned to matched string\n     */\n    commonPrefixSearch(key: string): { k: string; v: number }[] {\n        const buffer = encoder.encode(key);\n        const result: { k: string; v: number }[] = [];\n        let parent = ROOT_ID;\n        let child = NOT_FOUND;\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            child = this.#traverse(parent, code);\n            if (child !== NOT_FOUND) {\n                parent = child;\n                // look forward by terminal character code to check this node is a leaf or not\n                const grand_child = this.#traverse(child, TERM_CODE);\n                if (grand_child !== NOT_FOUND) {\n                    const base = this.#bufferController.getBase(grand_child);\n                    const r: { k: string; v: number } = {\n                        k: \"\",\n                        v: 0,\n                    };\n\n                    if (base <= 0) {\n                        // If child is a leaf node, add record to result\n                        r.v = -base - 1;\n                    }\n                    // If child is a leaf node, add word to result\n                    r.k = decoder.decode(buffer.slice(0, i + 1));\n                    result.push(r);\n                }\n                continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    #traverse(parent: number, code: number) {\n        const child = this.#bufferController.getBase(parent) + code;\n        if (this.#bufferController.getCheck(child) === parent) {\n            return child;\n        }\n        return NOT_FOUND;\n    }\n\n    size() {\n        return this.#bufferController.size();\n    }\n\n    calc() {\n        return this.#bufferController.calc();\n    }\n\n    dump() {\n        return this.#bufferController.dump();\n    }\n}\n\nexport { DoubleArrayBuilder, DoubleArray };\n\nexport default {\n    builder: (initial_size = 1024) => {\n        return new DoubleArrayBuilder(initial_size);\n    },\n    load: (base_buffer: ArrayBuffer, check_buffer: ArrayBuffer) => {\n        const bufferController = new BufferController(0);\n        bufferController.loadBaseBuffer(base_buffer);\n        bufferController.loadCheckBuffer(check_buffer);\n        return new DoubleArray(bufferController);\n    },\n};\n",
    "class ConnectionCosts {\n    forward_dimension: number;\n    backward_dimension: number;\n    #buffer: Int16Array;\n    constructor(forward_dimension: number, backward_dimension: number) {\n        this.forward_dimension = forward_dimension;\n        this.backward_dimension = backward_dimension;\n\n        // leading 2 integers for forward_dimension, backward_dimension, respectively\n        this.#buffer = new Int16Array(forward_dimension * backward_dimension + 2);\n        this.#buffer[0] = forward_dimension;\n        this.#buffer[1] = backward_dimension;\n    }\n\n    put(forward_id: number, backward_id: number, cost: number) {\n        const index = forward_id * this.backward_dimension + backward_id + 2;\n        if (this.#buffer.length < index + 1) {\n            throw \"ConnectionCosts buffer overflow\";\n        }\n        this.#buffer[index] = cost;\n    }\n\n    get(forward_id: number, backward_id: number) {\n        const index = forward_id * this.backward_dimension + backward_id + 2;\n        if (this.#buffer.length < index + 1) {\n            throw \"ConnectionCosts buffer overflow\";\n        }\n        return this.#buffer[index];\n    }\n\n    loadConnectionCosts(connection_costs_buffer: Int16Array) {\n        this.forward_dimension = connection_costs_buffer[0];\n        this.backward_dimension = connection_costs_buffer[1];\n        this.#buffer = connection_costs_buffer;\n    }\n}\n\nexport default ConnectionCosts;\n",
    "const encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nclass ByteBuffer {\n    #_buffer: Uint8Array;\n    #_position = 0;\n\n    get buffer() {\n        return this.#_buffer;\n    }\n\n    set buffer(value) {\n        this.#_buffer = value;\n    }\n\n    get position() {\n        return this.#_position;\n    }\n\n    set position(value) {\n        this.#_position = value;\n    }\n\n    constructor(arg?: number | Uint8Array) {\n        if (arg === undefined) {\n            this.#_buffer = new Uint8Array(1024 * 1024);\n            this.#_position = 0;\n        } else if (typeof arg === \"number\") {\n            this.#_buffer = new Uint8Array(arg);\n            this.#_position = 0;\n        } else if (arg instanceof Uint8Array) {\n            this.#_buffer = arg;\n            this.#_position = 0; // Overwrite\n        } else {\n            // typeof arg -> String\n            throw `${typeof arg} is invalid parameter type`;\n        }\n    }\n\n    size() {\n        return this.#_buffer.length;\n    }\n\n    reallocate() {\n        const new_array = new Uint8Array(this.#_buffer.length * 2);\n        new_array.set(this.#_buffer);\n        this.#_buffer = new_array;\n    }\n\n    shrink() {\n        this.#_buffer = this.#_buffer.subarray(0, this.#_position);\n        return this.#_buffer;\n    }\n\n    put(b: number | boolean) {\n        if (this.#_buffer.length < this.#_position + 1) {\n            this.reallocate();\n        }\n        if (typeof b === \"boolean\") {\n            this.#_buffer[this.#_position++] = b ? 1 : 0;\n        } else {\n            this.#_buffer[this.#_position++] = b;\n        }\n    }\n\n    get(_index: number | null = null) {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 1;\n        }\n        if (this.#_buffer.length < index + 1) {\n            return 0;\n        }\n        return this.#_buffer[index];\n    }\n\n    // Write short to buffer by little endian\n    putShort(num: number) {\n        if (0xffff < num) {\n            throw `${num} is over short value`;\n        }\n        const lower = 0x00ff & num;\n        const upper = (0xff00 & num) >> 8;\n        this.put(lower);\n        this.put(upper);\n    }\n\n    // Read short from buffer by little endian\n    getShort(_index: number | null) {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 2;\n        }\n        if (this.#_buffer.length < index + 2) {\n            return 0;\n        }\n        const lower = this.#_buffer[index];\n        const upper = this.#_buffer[index + 1];\n        let value = (upper << 8) + lower;\n        if (value & 0x8000) {\n            value = -((value - 1) ^ 0xffff);\n        }\n        return value;\n    }\n\n    // Write integer to buffer by little endian\n    putInt(num: number) {\n        if (0xffffffff < num) {\n            throw `${num} is over integer value`;\n        }\n        const b0 = 0x000000ff & num;\n        const b1 = (0x0000ff00 & num) >> 8;\n        const b2 = (0x00ff0000 & num) >> 16;\n        const b3 = (0xff000000 & num) >> 24;\n        this.put(b0);\n        this.put(b1);\n        this.put(b2);\n        this.put(b3);\n    }\n\n    // Read integer from buffer by little endian\n    getInt(_index: number | null = null) {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 4;\n        }\n        if (this.#_buffer.length < index + 4) {\n            return 0;\n        }\n        const b0 = this.#_buffer[index];\n        const b1 = this.#_buffer[index + 1];\n        const b2 = this.#_buffer[index + 2];\n        const b3 = this.#_buffer[index + 3];\n\n        return (b3 << 24) + (b2 << 16) + (b1 << 8) + b0;\n    }\n\n    readInt() {\n        const pos = this.#_position;\n        this.#_position += 4;\n        return this.getInt(pos);\n    }\n\n    putString(str: string) {\n        const bytes = encoder.encode(str);\n        for (const byte of bytes) {\n            this.put(byte);\n        }\n        // put null character as terminal character\n        this.put(0);\n    }\n\n    getString(_index: number = this.#_position) {\n        let index = _index;\n        const buf = [];\n        let ch: number;\n\n        while (index < this.#_buffer.length) {\n            ch = this.get(index++);\n            if (ch === 0) break;\n            buf.push(ch);\n        }\n\n        this.#_position = index;\n        return decoder.decode(new Uint8Array(buf));\n    }\n\n    getUtf32(_index: number | null = null): number {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 4;\n        }\n        if (this.#_buffer.length < index + 4) {\n            return 0;\n        }\n        const codePoint = this.#_buffer.subarray(index, index + 4);\n        return new DataView(codePoint.buffer).getUint32(0, false); // little-endian\n    }\n\n    getBool(_index: number | null = null) {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 1;\n        }\n        if (this.#_buffer.length < index + 1) {\n            return false;\n        }\n        return Boolean(this.#_buffer[index]);\n    }\n}\n\nexport default ByteBuffer;\n",
    "import ByteBuffer from \"../../_core/util/ByteBuffer\";\n\nclass TokenInfoDictionary {\n    dictionary: ByteBuffer;\n    target_map: Map<number, number[]>;\n    pos_buffer: ByteBuffer;\n    constructor() {\n        this.dictionary = new ByteBuffer(10 * 1024 * 1024);\n        this.target_map = new Map<number, number[]>(); // trie_id (of surface form) -> token_info_id (of token)\n        this.pos_buffer = new ByteBuffer(10 * 1024 * 1024);\n    }\n\n    // left_id right_id word_cost ...\n    // ^ this position is token_info_id\n    buildDictionary(entries: string[][]): { [word_id: number]: string } {\n        const dictionary_entries: { [word_id: number]: string } = {}; // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n        for (let i = 0; i < entries.length; i++) {\n            const entry = entries[i];\n            if (entry.length < 4) {\n                continue;\n            }\n            const surface_form = entry[0];\n            const left_id = Number.parseInt(entry[1]);\n            const right_id = Number.parseInt(entry[2]);\n            const word_cost = Number.parseInt(entry[3]);\n            const feature = entry.slice(4).join(\",\"); // TODO Optimize\n            // Assertion\n            if (!Number.isFinite(left_id) || !Number.isFinite(right_id) || !Number.isFinite(word_cost)) {\n                console.log(entry);\n            }\n            const token_info_id = this.put(left_id, right_id, word_cost, surface_form, feature);\n            dictionary_entries[token_info_id] = surface_form;\n        }\n\n        // Remove last unused area\n        this.dictionary.shrink();\n        this.pos_buffer.shrink();\n\n        return dictionary_entries;\n    }\n\n    put(left_id: number, right_id: number, word_cost: number, surface_form: string, feature: string): number {\n        const token_info_id = this.dictionary.position;\n        const pos_id = this.pos_buffer.position;\n\n        this.dictionary.putShort(left_id);\n        this.dictionary.putShort(right_id);\n        this.dictionary.putShort(word_cost);\n        this.dictionary.putInt(pos_id);\n        this.pos_buffer.putString(`${surface_form},${feature}`);\n\n        return token_info_id;\n    }\n\n    addMapping(source: number, target: number): void {\n        let mapping = this.target_map.get(source);\n        if (mapping == null) {\n            mapping = [];\n        }\n        mapping.push(target);\n\n        this.target_map.set(source, mapping);\n    }\n\n    targetMapToBuffer(): Uint8Array {\n        const buffer = new ByteBuffer();\n        buffer.putInt(Object.keys(this.target_map).length);\n        for (const _key in this.target_map) {\n            const key = Number.parseInt(_key);\n\n            const values = this.target_map.get(key); // Array\n            if (!values) continue;\n\n            const map_values_size = values.length;\n            buffer.putInt(key);\n            buffer.putInt(map_values_size);\n            for (const value of values) {\n                buffer.putInt(value);\n            }\n        }\n        return buffer.shrink(); // Shrink-ed Typed Array\n    }\n\n    // from tid.dat\n    loadDictionary(array_buffer: Uint8Array) {\n        this.dictionary = new ByteBuffer(array_buffer);\n        return this;\n    }\n\n    // from tid_pos.dat\n    loadPosVector(array_buffer: Uint8Array) {\n        this.pos_buffer = new ByteBuffer(array_buffer);\n        return this;\n    }\n\n    // from tid_map.dat\n    loadTargetMap(array_buffer: Uint8Array) {\n        const buffer = new ByteBuffer(array_buffer);\n        buffer.position = 0;\n        this.target_map = new Map<number, number[]>();\n        buffer.readInt(); // map_keys_size\n        while (true) {\n            if (buffer.buffer.length < buffer.position + 1) {\n                break;\n            }\n            const key = buffer.readInt();\n            const map_values_size = buffer.readInt();\n            for (let i = 0; i < map_values_size; i++) {\n                const value = buffer.readInt();\n                this.addMapping(key, value);\n            }\n        }\n        return this;\n    }\n\n    getFeatures(token_info_id: number): string | null {\n        if (Number.isNaN(token_info_id)) {\n            return null;\n        }\n        const pos_id = this.dictionary.getInt(token_info_id + 6);\n        return this.pos_buffer.getString(pos_id);\n    }\n}\n\nexport default TokenInfoDictionary;\n",
    "class SurrogateAwareString {\n    #str: string;\n    #index_mapping: number[];\n    length: number;\n    /**\n     * String wrapper for UTF-16 surrogate pair (4 bytes)\n     * @param {string} str String to wrap\n     * @constructor\n     */\n    constructor(str: string) {\n        this.#str = str;\n        this.#index_mapping = [];\n        for (let pos = 0; pos < str.length; pos++) {\n            const ch = str.charAt(pos);\n            this.#index_mapping.push(pos);\n            if (SurrogateAwareString.isSurrogatePair(ch)) {\n                pos++;\n            }\n        }\n        // Surrogate aware length\n        this.length = this.#index_mapping.length;\n    }\n\n    slice(index: number) {\n        if (this.#index_mapping.length <= index) {\n            return \"\";\n        }\n        const surrogate_aware_index = this.#index_mapping[index];\n        return this.#str.slice(surrogate_aware_index);\n    }\n\n    charAt(index: number) {\n        if (this.#str.length <= index) {\n            return \"\";\n        }\n        const surrogate_aware_start_index = this.#index_mapping[index];\n        const surrogate_aware_end_index = this.#index_mapping[index + 1];\n        if (surrogate_aware_end_index == null) {\n            return this.#str.slice(surrogate_aware_start_index);\n        }\n        return this.#str.slice(surrogate_aware_start_index, surrogate_aware_end_index);\n    }\n\n    charCodeAt(index: number) {\n        if (this.#index_mapping.length <= index) {\n            return Number.NaN;\n        }\n        const surrogate_aware_index = this.#index_mapping[index];\n        const upper = this.#str.charCodeAt(surrogate_aware_index);\n        let lower: number;\n        if (upper >= 0xd800 && upper <= 0xdbff && surrogate_aware_index < this.#str.length) {\n            lower = this.#str.charCodeAt(surrogate_aware_index + 1);\n            if (lower >= 0xdc00 && lower <= 0xdfff) {\n                return (upper - 0xd800) * 0x400 + lower - 0xdc00 + 0x10000;\n            }\n        }\n        return upper;\n    }\n\n    toString() {\n        return this.#str;\n    }\n\n    add(other: SurrogateAwareString): SurrogateAwareString {\n        return new SurrogateAwareString(this.#str + other.#str);\n    }\n\n    append(str: string): SurrogateAwareString {\n        return new SurrogateAwareString(this.#str + str);\n    }\n\n    static isSurrogatePair(ch: string) {\n        const utf16_code = ch.charCodeAt(0);\n        if (utf16_code >= 0xd800 && utf16_code <= 0xdbff) {\n            // surrogate pair\n            return true;\n        }\n        return false;\n    }\n}\n\nexport default SurrogateAwareString;\n",
    "class CharacterClass {\n    class_id: number;\n    class_name: string;\n    is_always_invoke: boolean;\n    is_grouping: boolean;\n    max_length: number;\n    /**\n     * CharacterClass\n     * @param {number} class_id\n     * @param {string} class_name\n     * @param {boolean} is_always_invoke\n     * @param {boolean} is_grouping\n     * @param {number} max_length\n     * @constructor\n     */\n    constructor(\n        class_id: number,\n        class_name: string,\n        is_always_invoke: boolean,\n        is_grouping: boolean,\n        max_length: number\n    ) {\n        this.class_id = class_id;\n        this.class_name = class_name;\n        this.is_always_invoke = is_always_invoke;\n        this.is_grouping = is_grouping;\n        this.max_length = max_length;\n    }\n}\n\nexport default CharacterClass;\n",
    "import ByteBuffer from \"../../_core/util/ByteBuffer\";\nimport CharacterClass from \"./CharacterClass\";\n\n/**\n * InvokeDefinitionMap represents invoke definition a part of char.def\n * @constructor\n */\nclass InvokeDefinitionMap {\n    #map: CharacterClass[];\n    #lookup_table: Map<string, number>;\n    constructor() {\n        this.#map = [];\n        this.#lookup_table = new Map<string, number>(); // Just for building dictionary\n    }\n\n    /**\n     * Load InvokeDefinitionMap from buffer\n     * @param {Uint8Array} invoke_def_buffer\n     * @returns {InvokeDefinitionMap}\n     */\n    static load(invoke_def_buffer: Uint8Array): InvokeDefinitionMap {\n        const invoke_def = new InvokeDefinitionMap();\n        const character_category_definition: CharacterClass[] = [];\n\n        const buffer = new ByteBuffer(invoke_def_buffer);\n        while (buffer.position + 1 < buffer.size()) {\n            const is_always_invoke = buffer.getBool();\n            const is_grouping = buffer.getBool();\n            const max_length = buffer.getInt();\n            const class_name = buffer.getString();\n            character_category_definition.push(\n                new CharacterClass(\n                    character_category_definition.length,\n                    class_name,\n                    is_always_invoke,\n                    is_grouping,\n                    max_length\n                )\n            );\n        }\n\n        invoke_def.init(character_category_definition);\n\n        return invoke_def;\n    }\n\n    /**\n     * Initializing method\n     * @param {Array.<CharacterClass>} character_category_definition Array of CharacterClass\n     */\n    init(character_category_definition: CharacterClass[]) {\n        if (character_category_definition == null) {\n            return;\n        }\n        const ccd_length = character_category_definition.length;\n        for (let i = 0; i < ccd_length; i++) {\n            const character_class = character_category_definition[i];\n            this.#map[i] = character_class;\n            this.#lookup_table.set(character_class.class_name, i);\n        }\n    }\n\n    /**\n     * Get class information by class ID\n     * @param {number} class_id\n     * @returns {CharacterClass}\n     */\n    getCharacterClass(class_id: number) {\n        return this.#map[class_id];\n    }\n\n    /**\n     * For building character definition dictionary\n     * @param {string} class_name character\n     * @returns {number} class_id\n     */\n    lookup(class_name: string): number | null {\n        const class_id = this.#lookup_table.get(class_name);\n        if (class_id == null) {\n            return null;\n        }\n        return class_id;\n    }\n\n    /**\n     * Transform from map to binary buffer\n     * @returns {Uint8Array}\n     */\n    toBuffer() {\n        const buffer = new ByteBuffer();\n        for (let i = 0; i < this.#map.length; i++) {\n            const char_class = this.#map[i];\n            buffer.put(char_class.is_always_invoke);\n            buffer.put(char_class.is_grouping);\n            buffer.putInt(char_class.max_length);\n            buffer.putString(char_class.class_name);\n        }\n        buffer.shrink();\n        return buffer.buffer;\n    }\n}\n\nexport default InvokeDefinitionMap;\n",
    "import SurrogateAwareString from \"../../_core/util/SurrogateAwareString\";\nimport CharacterClass from \"./CharacterClass\";\nimport InvokeDefinitionMap from \"./InvokeDefinitionMap\";\n\nconst DEFAULT_CATEGORY = \"DEFAULT\";\n\nclass CharacterDefinition {\n    character_category_map: Uint8Array;\n    compatible_category_map: Uint32Array;\n    invoke_definition_map: null | InvokeDefinitionMap;\n    /**\n     * CharacterDefinition represents char.def file and\n     * defines behavior of unknown word processing\n     * @constructor\n     */\n    constructor() {\n        this.character_category_map = new Uint8Array(65536); // for all UCS2 code points\n        this.compatible_category_map = new Uint32Array(65536); // for all UCS2 code points\n        this.invoke_definition_map = null;\n    }\n\n    /**\n     * Load CharacterDefinition\n     * @param {Uint8Array} cat_map_buffer\n     * @param {Uint32Array} compat_cat_map_buffer\n     * @param {Uint8Array} invoke_def_buffer\n     * @returns {CharacterDefinition}\n     */\n    load(cat_map_buffer: Uint8Array, compat_cat_map_buffer: Uint32Array, invoke_def_buffer: Uint8Array) {\n        const char_def = new CharacterDefinition();\n        char_def.character_category_map = cat_map_buffer;\n        char_def.compatible_category_map = compat_cat_map_buffer;\n        char_def.invoke_definition_map = InvokeDefinitionMap.load(invoke_def_buffer);\n        return char_def;\n    }\n\n    static parseCharCategory(class_id: number, parsed_category_def: RegExpExecArray) {\n        const category = parsed_category_def[1];\n        const invoke = Number.parseInt(parsed_category_def[2]);\n        const grouping = Number.parseInt(parsed_category_def[3]);\n        const max_length = Number.parseInt(parsed_category_def[4]);\n        if (!Number.isFinite(invoke) || (invoke !== 0 && invoke !== 1)) {\n            console.log(`char.def parse error. INVOKE is 0 or 1 in:${invoke}`);\n            return null;\n        }\n        if (!Number.isFinite(grouping) || (grouping !== 0 && grouping !== 1)) {\n            console.log(`char.def parse error. GROUP is 0 or 1 in:${grouping}`);\n            return null;\n        }\n        if (!Number.isFinite(max_length) || max_length < 0) {\n            console.log(`char.def parse error. LENGTH is 1 to n:${max_length}`);\n            return null;\n        }\n        return new CharacterClass(class_id, category, invoke === 1, grouping === 1, max_length);\n    }\n\n    static parseCategoryMapping(parsed_category_mapping: RegExpExecArray) {\n        const start = Number.parseInt(parsed_category_mapping[1]);\n        if (!Number.isFinite(start) || start < 0 || start > 0xffff) {\n            console.log(`char.def parse error. CODE is invalid:${start}`);\n        }\n        return {\n            start: start,\n            default: parsed_category_mapping[2],\n            compatible: 3 < parsed_category_mapping.length ? parsed_category_mapping.slice(3) : [],\n        };\n    }\n\n    static parseRangeCategoryMapping(parsed_category_mapping: RegExpExecArray) {\n        const start = Number.parseInt(parsed_category_mapping[1]);\n        const end = Number.parseInt(parsed_category_mapping[2]);\n        if (!Number.isFinite(start) || start < 0 || start > 0xffff) {\n            console.log(`char.def parse error. CODE is invalid:${start}`);\n        }\n        if (!Number.isFinite(end) || end < 0 || end > 0xffff) {\n            console.log(`char.def parse error. CODE is invalid:${end}`);\n        }\n        return {\n            start: start,\n            end: end,\n            default: parsed_category_mapping[3],\n            compatible: 4 < parsed_category_mapping.length ? parsed_category_mapping.slice(4) : [],\n        };\n    }\n\n    /**\n     * Initializing method\n     * @param {Array} category_mapping Array of category mapping\n     */\n    initCategoryMappings(category_mapping: { start: number; end?: number; default: string; compatible: string[] }[]) {\n        if (!this.invoke_definition_map) {\n            throw new Error(\"CharacterDefinition.initCategoryMappings: invoke_definition_map is null\");\n        }\n        // Initialize map by DEFAULT class\n        let code_point = 0;\n        if (category_mapping != null) {\n            const category_mapping_length = category_mapping.length;\n            for (let i = 0; i < category_mapping_length; i++) {\n                const mapping = category_mapping[i];\n                for (code_point = mapping.start; code_point <= (mapping.end || mapping.start); code_point++) {\n                    // Default Category class ID\n                    const id = this.invoke_definition_map.lookup(mapping.default);\n                    if (id == null) {\n                        throw new Error(\n                            \"CharacterDefinition.initCategoryMappings: invoke_definition_map.lookup() returns null\"\n                        );\n                    }\n                    this.character_category_map[code_point] = id;\n\n                    for (let j = 0; j < mapping.compatible.length; j++) {\n                        let bitset = this.compatible_category_map[code_point];\n                        const compatible_category = mapping.compatible[j];\n                        if (compatible_category == null) {\n                            continue;\n                        }\n                        const class_id = this.invoke_definition_map.lookup(compatible_category); // Default Category\n                        if (class_id == null) {\n                            continue;\n                        }\n                        const class_id_bit = 1 << class_id;\n                        bitset = bitset | class_id_bit; // Set a bit of class ID 例えば、class_idが3のとき、3ビット目に1を立てる\n                        this.compatible_category_map[code_point] = bitset;\n                    }\n                }\n            }\n        }\n        const default_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n        if (default_id == null) {\n            return;\n        }\n        const ccm_length = this.compatible_category_map.length;\n        for (code_point = 0; code_point < ccm_length; code_point++) {\n            // 他に何のクラスも定義されていなかったときだけ DEFAULT\n            if (this.character_category_map[code_point] === 0) {\n                // DEFAULT class ID に対応するビットだけ1を立てる\n                this.character_category_map[code_point] = 1 << default_id;\n            }\n        }\n    }\n\n    /**\n     * Lookup compatible categories for a character (not included 1st category)\n     * @param {string} ch UCS2 character (just 1st character is effective)\n     * @returns {Array.<CharacterClass>} character classes\n     */\n    lookupCompatibleCategory(ch: string) {\n        const classes: CharacterClass[] = [];\n        if (!this.invoke_definition_map) {\n            throw new Error(\"CharacterDefinition.lookupCompatibleCategory: invoke_definition_map is null\");\n        }\n        /*\n        if (SurrogateAwareString.isSurrogatePair(ch)) {\n        // Surrogate pair character codes can not be defined by char.def\n        return classes;\n        }\n        */\n        const code = ch.charCodeAt(0);\n        let integer: number | null = null;\n        if (code < this.compatible_category_map.length) {\n            integer = this.compatible_category_map[code]; // Bitset\n        }\n        if (integer == null || integer === 0) {\n            return classes;\n        }\n        for (let bit = 0; bit < 32; bit++) {\n            // Treat \"bit\" as a class ID\n            if ((integer << (31 - bit)) >>> 31 === 1) {\n                const character_class = this.invoke_definition_map.getCharacterClass(bit);\n                if (character_class == null) {\n                    continue;\n                }\n                classes.push(character_class);\n            }\n        }\n        return classes;\n    }\n\n    /**\n     * Lookup category for a character\n     * @param {string} ch UCS2 character (just 1st character is effective)\n     * @returns {CharacterClass} character class\n     */\n    lookup(ch: string) {\n        if (!this.invoke_definition_map) {\n            throw new Error(\"CharacterDefinition.lookup: invoke_definition_map is null\");\n        }\n        let class_id: number | null = null;\n        const code = ch.charCodeAt(0);\n        if (SurrogateAwareString.isSurrogatePair(ch)) {\n            // Surrogate pair character codes can not be defined by char.def, so set DEFAULT category\n            class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n        } else if (code < this.character_category_map.length) {\n            class_id = this.character_category_map[code]; // Read as integer value\n        }\n\n        if (class_id == null) {\n            class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n        }\n\n        return this.invoke_definition_map.getCharacterClass(class_id as number);\n    }\n}\n\nexport default CharacterDefinition;\n",
    "import CharacterDefinition from \"./CharacterDefinition\";\nimport TokenInfoDictionary from \"./TokenInfoDictionary\";\n\nclass UnknownDictionary extends TokenInfoDictionary {\n    #character_definition: CharacterDefinition | null = null;\n\n    characterDefinition(character_definition: CharacterDefinition) {\n        this.#character_definition = character_definition;\n        return this;\n    }\n\n    lookup(ch: string) {\n        if (this.#character_definition == null) {\n            throw new Error(\"CharacterDefinition is not set\");\n        }\n        return this.#character_definition.lookup(ch);\n    }\n\n    lookupCompatibleCategory(ch: string) {\n        if (this.#character_definition == null) {\n            throw new Error(\"CharacterDefinition is not set\");\n        }\n        return this.#character_definition.lookupCompatibleCategory(ch);\n    }\n\n    loadUnknownDictionaries(\n        unk_buffer: Uint8Array,\n        unk_pos_buffer: Uint8Array,\n        unk_map_buffer: Uint8Array,\n        cat_map_buffer: Uint8Array,\n        compat_cat_map_buffer: Uint32Array,\n        invoke_def_buffer: Uint8Array\n    ) {\n        this.loadDictionary(unk_buffer);\n        this.loadPosVector(unk_pos_buffer);\n        this.loadTargetMap(unk_map_buffer);\n        this.#character_definition = new CharacterDefinition().load(\n            cat_map_buffer,\n            compat_cat_map_buffer,\n            invoke_def_buffer\n        );\n    }\n}\n\nexport default UnknownDictionary;\n",
    "import doublearray from \"../../_core/util/DoubleArray\";\nimport type { DoubleArray } from \"../../_core/util/DoubleArray\";\nimport ConnectionCosts from \"./ConnectionCosts\";\nimport TokenInfoDictionary from \"./TokenInfoDictionary\";\nimport UnknownDictionary from \"./UnknownDictionary\";\n\nclass DynamicDictionaries {\n    trie: DoubleArray;\n    token_info_dictionary: TokenInfoDictionary;\n    connection_costs: ConnectionCosts;\n    unknown_dictionary: UnknownDictionary;\n    constructor(\n        trie?: DoubleArray,\n        token_info_dictionary?: TokenInfoDictionary,\n        connection_costs?: ConnectionCosts,\n        unknown_dictionary?: UnknownDictionary\n    ) {\n        this.trie = trie ?? doublearray.builder(0).build([{ k: \"\", v: 1 }]);\n        this.token_info_dictionary = token_info_dictionary ?? new TokenInfoDictionary();\n        // backward_size * backward_size\n        this.connection_costs = connection_costs ?? new ConnectionCosts(0, 0);\n        this.unknown_dictionary = unknown_dictionary ?? new UnknownDictionary();\n    }\n\n    loadTrie(base_buffer: Int32Array, check_buffer: Int32Array) {\n        this.trie = doublearray.load(base_buffer, check_buffer);\n        return this;\n    }\n\n    loadTokenInfoDictionaries(token_info_buffer: Uint8Array, pos_buffer: Uint8Array, target_map_buffer: Uint8Array) {\n        this.token_info_dictionary.loadDictionary(token_info_buffer);\n        this.token_info_dictionary.loadPosVector(pos_buffer);\n        this.token_info_dictionary.loadTargetMap(target_map_buffer);\n        return this;\n    }\n\n    loadConnectionCosts(cc_buffer: Int16Array) {\n        this.connection_costs.loadConnectionCosts(cc_buffer);\n        return this;\n    }\n\n    loadUnknownDictionaries(\n        unk_buffer: Uint8Array,\n        unk_pos_buffer: Uint8Array,\n        unk_map_buffer: Uint8Array,\n        cat_map_buffer: Uint8Array,\n        compat_cat_map_buffer: Uint32Array,\n        invoke_def_buffer: Uint8Array\n    ) {\n        this.unknown_dictionary.loadUnknownDictionaries(\n            unk_buffer,\n            unk_pos_buffer,\n            unk_map_buffer,\n            cat_map_buffer,\n            compat_cat_map_buffer,\n            invoke_def_buffer\n        );\n        return this;\n    }\n}\n\nexport default DynamicDictionaries;\n",
    "import type CharacterClass from \"../CharacterClass\";\nimport CharacterDefinition from \"../CharacterDefinition\";\nimport InvokeDefinitionMap from \"../InvokeDefinitionMap\";\n\nconst CATEGORY_DEF_PATTERN = /^(\\w+)\\s+(\\d)\\s+(\\d)\\s+(\\d)/;\nconst CATEGORY_MAPPING_PATTERN = /^(0x[0-9A-F]{4})(?:\\s+([^#\\s]+))(?:\\s+([^#\\s]+))*/;\nconst RANGE_CATEGORY_MAPPING_PATTERN = /^(0x[0-9A-F]{4})\\.\\.(0x[0-9A-F]{4})(?:\\s+([^#\\s]+))(?:\\s+([^#\\s]+))*/;\n\nclass CharacterDefinitionBuilder {\n    char_def: CharacterDefinition;\n    character_category_definition: CharacterClass[];\n    category_mapping: {\n        start: number;\n        default: string;\n        compatible: string[];\n        end?: number;\n    }[];\n    /**\n     * CharacterDefinitionBuilder\n     * @constructor\n     */\n    constructor() {\n        this.char_def = new CharacterDefinition();\n        this.char_def.invoke_definition_map = new InvokeDefinitionMap();\n        this.character_category_definition = [];\n        this.category_mapping = [];\n    }\n\n    putLine(line: string) {\n        const parsed_category_def = CATEGORY_DEF_PATTERN.exec(line);\n        if (parsed_category_def != null) {\n            const class_id = this.character_category_definition.length;\n            const char_class = CharacterDefinition.parseCharCategory(class_id, parsed_category_def);\n            if (char_class == null) {\n                return;\n            }\n            this.character_category_definition.push(char_class);\n            return;\n        }\n        const parsed_category_mapping = CATEGORY_MAPPING_PATTERN.exec(line);\n        if (parsed_category_mapping != null) {\n            const mapping = CharacterDefinition.parseCategoryMapping(parsed_category_mapping);\n            this.category_mapping.push(mapping);\n        }\n        const parsed_range_category_mapping = RANGE_CATEGORY_MAPPING_PATTERN.exec(line);\n        if (parsed_range_category_mapping != null) {\n            const range_mapping = CharacterDefinition.parseRangeCategoryMapping(parsed_range_category_mapping);\n            this.category_mapping.push(range_mapping);\n        }\n    }\n\n    build() {\n        // TODO If DEFAULT category does not exist, throw error\n        if (!this.char_def || !this.char_def.invoke_definition_map) {\n            throw new Error(\"No data to build.\");\n        }\n        this.char_def.invoke_definition_map.init(this.character_category_definition);\n        this.char_def.initCategoryMappings(this.category_mapping);\n        return this.char_def;\n    }\n}\n\nexport default CharacterDefinitionBuilder;\n",
    "import ConnectionCosts from \"../ConnectionCosts\";\n\nclass ConnectionCostsBuilder {\n    lines: number;\n    connection_cost: null | ConnectionCosts;\n    /**\n     * Builder class for constructing ConnectionCosts object\n     * @constructor\n     */\n    constructor() {\n        this.lines = 0;\n        this.connection_cost = null;\n    }\n\n    putLine(line: string) {\n        if (this.lines === 0 || !this.connection_cost) {\n            const dimensions = line.split(\" \");\n            const forward_dimension = Number.parseInt(dimensions[0]);\n            const backward_dimension = Number.parseInt(dimensions[1]);\n\n            if (forward_dimension < 0 || backward_dimension < 0) {\n                throw \"Parse error of matrix.def\";\n            }\n\n            this.connection_cost = new ConnectionCosts(forward_dimension, backward_dimension);\n            this.lines++;\n            return this;\n        }\n        if (!this.connection_cost) {\n            throw \"connection_cost is null\";\n        }\n\n        const costs = line.split(\" \");\n\n        if (costs.length !== 3) {\n            return this;\n        }\n\n        const forward_id = Number.parseInt(costs[0]);\n        const backward_id = Number.parseInt(costs[1]);\n        const cost = Number.parseInt(costs[2]);\n\n        if (\n            forward_id < 0 ||\n            backward_id < 0 ||\n            !Number.isFinite(forward_id) ||\n            !Number.isFinite(backward_id) ||\n            this.connection_cost.forward_dimension <= forward_id ||\n            this.connection_cost.backward_dimension <= backward_id\n        ) {\n            throw \"Parse error of matrix.def\";\n        }\n\n        this.connection_cost.put(forward_id, backward_id, cost);\n        this.lines++;\n        return this;\n    }\n\n    build() {\n        if (!this.connection_cost) {\n            throw \"No data to build.\";\n        }\n        return this.connection_cost;\n    }\n}\n\nexport default ConnectionCostsBuilder;\n",
    "import doublearray from \"../../../_core/util/DoubleArray\";\nimport DynamicDictionaries from \"../DynamicDictionaries\";\nimport TokenInfoDictionary from \"../TokenInfoDictionary\";\nimport UnknownDictionary from \"../UnknownDictionary\";\nimport CharacterDefinitionBuilder from \"./CharacterDefinitionBuilder\";\nimport ConnectionCostsBuilder from \"./ConnectionCostsBuilder\";\n\nclass DictionaryBuilder {\n    #tid_entries: string[][];\n    #unk_entries: string[][];\n    #cc_builder: ConnectionCostsBuilder;\n    #cd_builder: CharacterDefinitionBuilder;\n    /**\n     * Build dictionaries (token info, connection costs)\n     *\n     * Generates from matrix.def\n     * cc.dat: Connection costs\n     *\n     * Generates from *.csv\n     * dat.dat: Double array\n     * tid.dat: Token info dictionary\n     * tid_map.dat: targetMap\n     * tid_pos.dat: posList (part of speech)\n     */\n    constructor() {\n        // Array of entries, each entry in Mecab form\n        // (0: surface form, 1: left id, 2: right id, 3: word cost, 4: part of speech id, 5-: other features)\n        this.#tid_entries = [];\n        this.#unk_entries = [];\n        this.#cc_builder = new ConnectionCostsBuilder();\n        this.#cd_builder = new CharacterDefinitionBuilder();\n    }\n\n    addTokenInfoDictionary(line: string) {\n        const new_entry = line.split(\",\");\n        this.#tid_entries.push(new_entry);\n        return this;\n    }\n\n    /**\n     * Put one line of \"matrix.def\" file for building ConnectionCosts object\n     * @param {string} line is a line of \"matrix.def\"\n     */\n    putCostMatrixLine(line: string) {\n        this.#cc_builder.putLine(line);\n        return this;\n    }\n\n    putCharDefLine(line: string) {\n        this.#cd_builder.putLine(line);\n        return this;\n    }\n\n    /**\n     * Put one line of \"unk.def\" file for building UnknownDictionary object\n     * @param {string} line is a line of \"unk.def\"\n     */\n    putUnkDefLine(line: string) {\n        this.#unk_entries.push(line.split(\",\"));\n        return this;\n    }\n\n    build() {\n        const dictionaries = this.buildTokenInfoDictionary();\n\n        return new DynamicDictionaries(\n            dictionaries.trie,\n            dictionaries.token_info_dictionary,\n            this.#cc_builder.build(),\n            this.buildUnknownDictionary()\n        );\n    }\n\n    /**\n     * Build TokenInfoDictionary\n     *\n     * @returns {{trie: *, token_info_dictionary: *}}\n     */\n    buildTokenInfoDictionary() {\n        const token_info_dictionary = new TokenInfoDictionary();\n        // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n        const dictionary_entries = token_info_dictionary.buildDictionary(this.#tid_entries);\n        const trie = this.buildDoubleArray();\n        for (const token_info_id in dictionary_entries) {\n            const surface_form = dictionary_entries[token_info_id];\n            const trie_id = trie.lookup(surface_form);\n            // Assertion\n            // if (trie_id < 0) {\n            //     console.log(\"Not Found:\" + surface_form);\n            // }\n            token_info_dictionary.addMapping(trie_id, Number.parseInt(token_info_id));\n        }\n        return {\n            trie: trie,\n            token_info_dictionary: token_info_dictionary,\n        };\n    }\n\n    buildUnknownDictionary() {\n        const unk_dictionary = new UnknownDictionary();\n        // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n        const dictionary_entries = unk_dictionary.buildDictionary(this.#unk_entries);\n        const char_def = this.#cd_builder.build(); // Create CharacterDefinition\n        if (!char_def || !char_def.invoke_definition_map) {\n            throw new Error(\"CharacterDefinition is not set\");\n        }\n        unk_dictionary.characterDefinition(char_def);\n        for (const token_info_id in dictionary_entries) {\n            const class_name = dictionary_entries[token_info_id];\n            const class_id = char_def.invoke_definition_map.lookup(class_name);\n            if (!class_id) {\n                throw new Error(`Class name not found: ${class_name}`);\n            }\n            // Assertion\n            // if (trie_id < 0) {\n            //     console.log(\"Not Found:\" + surface_form);\n            // }\n            unk_dictionary.addMapping(class_id, Number.parseInt(token_info_id));\n        }\n        return unk_dictionary;\n    }\n\n    /**\n     * Build double array trie\n     *\n     * @returns {DoubleArray} Double-Array trie\n     */\n    buildDoubleArray() {\n        let trie_id = 0;\n        const words = this.#tid_entries.map((entry) => {\n            const surface_form = entry[0];\n            return { k: surface_form, v: trie_id++ };\n        });\n\n        const builder = doublearray.builder(1024 * 1024);\n        return builder.build(words);\n    }\n}\n\nexport default DictionaryBuilder;\n",
    "import type { WORD_TYPE } from \"../viterbi/ViterbiNode\";\n\nexport type TOKEN = {\n    word_id: number;\n    word_type: WORD_TYPE;\n    word_position: number;\n    surface_form: string | Uint8Array;\n    pos: string;\n    pos_detail_1: string;\n    pos_detail_2: string;\n    pos_detail_3: string;\n    conjugated_type: string;\n    conjugated_form: string;\n    basic_form: string;\n    reading?: string;\n    pronunciation?: string;\n};\n\n/**\n * Mappings between IPADIC dictionary features and tokenized results\n * @constructor\n */\nclass IpadicFormatter {\n    formatEntry(word_id: number, position: number, type: WORD_TYPE, features: string[]): TOKEN {\n        return {\n            word_id: word_id,\n            word_type: type,\n            word_position: position,\n            surface_form: features[0],\n            pos: features[1],\n            pos_detail_1: features[2],\n            pos_detail_2: features[3],\n            pos_detail_3: features[4],\n            conjugated_type: features[5],\n            conjugated_form: features[6],\n            basic_form: features[7],\n            reading: features[8],\n            pronunciation: features[9],\n        };\n    }\n\n    formatUnknownEntry(\n        word_id: number,\n        position: number,\n        type: WORD_TYPE,\n        features: string[],\n        surface_form: string | Uint8Array\n    ): TOKEN {\n        return {\n            word_id: word_id,\n            word_type: type,\n            word_position: position,\n            surface_form: surface_form,\n            pos: features[1],\n            pos_detail_1: features[2],\n            pos_detail_2: features[3],\n            pos_detail_3: features[4],\n            conjugated_type: features[5],\n            conjugated_form: features[6],\n            basic_form: features[7],\n            // token.reading = features[8];\n            // token.pronunciation = features[9];\n        };\n    }\n}\n\nexport default IpadicFormatter;\n",
    "export type WORD_TYPE = \"KNOWN\" | \"UNKNOWN\" | \"BOS\" | \"EOS\";\n\nclass ViterbiNode {\n    name: number;\n    cost: number;\n    start_pos: number;\n    length: number;\n    left_id: number;\n    right_id: number;\n    prev: null | ViterbiNode;\n    surface_form: string | Uint8Array;\n    shortest_cost: number;\n    type: WORD_TYPE;\n\n    /**\n     * ViterbiNode is a node of ViterbiLattice\n     * @param {number} node_name Word ID\n     * @param {number} node_cost Word cost to generate\n     * @param {number} start_pos Start position from 1\n     * @param {number} length Word length\n     * @param {string} type Node type (KNOWN, UNKNOWN, BOS, EOS, ...)\n     * @param {number} left_id Left context ID\n     * @param {number} right_id Right context ID\n     * @param {string} surface_form Surface form of this word\n     * @constructor\n     */\n    constructor(\n        node_name: number,\n        node_cost: number,\n        start_pos: number,\n        length: number,\n        type: WORD_TYPE,\n        left_id: number,\n        right_id: number,\n        surface_form: string | Uint8Array\n    ) {\n        this.name = node_name;\n        this.cost = node_cost;\n        this.start_pos = start_pos;\n        this.length = length;\n        this.left_id = left_id;\n        this.right_id = right_id;\n        this.prev = null;\n        this.surface_form = surface_form;\n        this.shortest_cost = type === \"BOS\" ? 0 : Number.MAX_VALUE;\n        this.type = type;\n    }\n}\n\nexport default ViterbiNode;\n",
    "import ViterbiNode from \"./ViterbiNode\";\n\nclass ViterbiLattice {\n    nodes_end_at: ViterbiNode[][];\n    eos_pos: number;\n    /**\n     * ViterbiLattice is a lattice in Viterbi algorithm\n     * @constructor\n     */\n    constructor() {\n        this.nodes_end_at = [];\n        this.nodes_end_at[0] = [new ViterbiNode(-1, 0, 0, 0, \"BOS\", 0, 0, \"\")];\n        this.eos_pos = 1;\n    }\n\n    /**\n     * Append node to ViterbiLattice\n     * @param {ViterbiNode} node\n     */\n    append(node: ViterbiNode) {\n        const last_pos = node.start_pos + node.length - 1;\n        if (this.eos_pos < last_pos) {\n            this.eos_pos = last_pos;\n        }\n\n        const prev_nodes = this.nodes_end_at[last_pos] ?? [];\n        prev_nodes.push(node);\n\n        this.nodes_end_at[last_pos] = prev_nodes;\n    }\n\n    /**\n     * Set ends with EOS (End of Statement)\n     */\n    appendEos() {\n        const last_index = this.nodes_end_at.length;\n        this.eos_pos++;\n        this.nodes_end_at[last_index] = [new ViterbiNode(-1, 0, this.eos_pos, 0, \"EOS\", 0, 0, \"\")];\n    }\n}\n\nexport default ViterbiLattice;\n",
    "import type DynamicDictionaries from \"../dict/DynamicDictionaries\";\nimport type TokenInfoDictionary from \"../dict/TokenInfoDictionary\";\nimport type UnknownDictionary from \"../dict/UnknownDictionary\";\nimport type { DoubleArray } from \"../util/DoubleArray\";\nimport SurrogateAwareString from \"../util/SurrogateAwareString\";\nimport ViterbiLattice from \"./ViterbiLattice\";\nimport ViterbiNode from \"./ViterbiNode\";\n\nclass ViterbiBuilder {\n    #trie: DoubleArray;\n    #token_info_dictionary: TokenInfoDictionary;\n    #unknown_dictionary: UnknownDictionary;\n    /**\n     * ViterbiBuilder builds word lattice (ViterbiLattice)\n     * @param {DynamicDictionaries} dic dictionary\n     * @constructor\n     */\n    constructor(dic: DynamicDictionaries) {\n        this.#trie = dic.trie;\n        this.#token_info_dictionary = dic.token_info_dictionary;\n        this.#unknown_dictionary = dic.unknown_dictionary;\n    }\n\n    /**\n     * Build word lattice\n     * @param {string} sentence_str Input text\n     * @returns {ViterbiLattice} Word lattice\n     */\n    build(sentence_str: string) {\n        const lattice = new ViterbiLattice();\n        const sentence = new SurrogateAwareString(sentence_str);\n        const sentence_length = sentence.length;\n        for (let pos = 0; pos < sentence_length; pos++) {\n            const tail = sentence.slice(pos);\n            const vocabulary = this.#trie.commonPrefixSearch(tail);\n            const vocabulary_length = vocabulary.length;\n            for (let n = 0; n < vocabulary_length; n++) {\n                // Words in dictionary do not have surrogate pair (only UCS2 set)\n                const trie_id = vocabulary[n].v;\n                const key = vocabulary[n].k;\n                const token_info_ids = this.#token_info_dictionary.target_map.get(trie_id);\n                if (!token_info_ids) throw new Error(\"TokenInfo dictionary is broken\");\n                for (const token_info_id of token_info_ids) {\n                    const left_id = this.#token_info_dictionary.dictionary.getShort(token_info_id);\n                    const right_id = this.#token_info_dictionary.dictionary.getShort(token_info_id + 2);\n                    const word_cost = this.#token_info_dictionary.dictionary.getShort(token_info_id + 4);\n                    // node_name, cost, start_index, length, type, left_id, right_id, surface_form\n                    lattice.append(\n                        new ViterbiNode(token_info_id, word_cost, pos + 1, key.length, \"KNOWN\", left_id, right_id, key)\n                    );\n                }\n            }\n\n            const head_char = tail.charAt(0);\n            const head_char_class = this.#unknown_dictionary.lookup(head_char);\n            if (!vocabulary?.length || head_char_class.is_always_invoke) {\n                let key = head_char;\n                const tail_length = tail.length;\n                if (head_char_class.is_grouping && tail_length > 1) {\n                    const class_name = head_char_class.class_name;\n                    for (let k = 1; k < tail_length; k++) {\n                        const next_char = tail.charAt(k);\n                        if (this.#unknown_dictionary.lookup(next_char).class_name !== class_name) {\n                            break;\n                        }\n                        key += next_char;\n                    }\n                }\n                const unk_ids = this.#unknown_dictionary.target_map.get(head_char_class.class_id);\n                if (!unk_ids) throw new Error(\"Unknown dictionary is broken\");\n                const unk_length = unk_ids.length;\n                const unknown_dict = this.#unknown_dictionary.dictionary;\n                for (let j = 0; j < unk_length; j++) {\n                    const unk_id = unk_ids[j];\n                    lattice.append(\n                        new ViterbiNode(\n                            unk_id,\n                            unknown_dict.getShort(unk_id + 4),\n                            pos + 1,\n                            key.length,\n                            \"UNKNOWN\",\n                            unknown_dict.getShort(unk_id),\n                            unknown_dict.getShort(unk_id + 2),\n                            key\n                        )\n                    );\n                }\n            }\n        }\n\n        lattice.appendEos();\n\n        return lattice;\n    }\n}\n\nexport default ViterbiBuilder;\n",
    "import type ConnectionCosts from \"../dict/ConnectionCosts\";\nimport type ViterbiLattice from \"./ViterbiLattice\";\nimport type ViterbiNode from \"./ViterbiNode\";\n\nclass ViterbiSearcher {\n    #connection_costs: ConnectionCosts;\n    /**\n     * ViterbiSearcher is for searching best Viterbi path\n     * @param {ConnectionCosts} connection_costs Connection costs matrix\n     * @constructor\n     */\n    constructor(connection_costs: ConnectionCosts) {\n        this.#connection_costs = connection_costs;\n    }\n\n    /**\n     * Search best path by forward-backward algorithm\n     * @param {ViterbiLattice} lattice Viterbi lattice to search\n     * @returns {Array} Shortest path\n     */\n    search(_lattice: ViterbiLattice) {\n        let lattice = _lattice;\n        lattice = this.#forward(lattice);\n        return this.#backward(lattice);\n    }\n\n    #forward(lattice: ViterbiLattice) {\n        let i = 1;\n        for (i = 1; i <= lattice.eos_pos; i++) {\n            const nodes = lattice.nodes_end_at[i];\n            if (nodes == null) continue;\n            for (const node of nodes) {\n                let cost = Number.MAX_VALUE;\n                let shortest_prev_node: ViterbiNode | null = null;\n                const index = node.start_pos - 1;\n                if (!(index in lattice.nodes_end_at)) {\n                    // TODO process unknown words (repair word lattice)\n                    continue;\n                }\n                const prev_nodes = lattice.nodes_end_at[index];\n                for (const prev_node of prev_nodes) {\n                    let edge_cost: number;\n                    if (node.left_id == null || prev_node.right_id == null) {\n                        // TODO assert\n                        console.log(\"Left or right is null\");\n                        edge_cost = 0;\n                    } else {\n                        edge_cost = this.#connection_costs.get(prev_node.right_id, node.left_id);\n                    }\n                    const _cost = prev_node.shortest_cost + edge_cost + node.cost;\n                    if (_cost < cost) {\n                        shortest_prev_node = prev_node;\n                        cost = _cost;\n                    }\n                }\n                node.prev = shortest_prev_node;\n                node.shortest_cost = cost;\n            }\n        }\n        return lattice;\n    }\n\n    #backward(lattice: ViterbiLattice) {\n        const shortest_path: ViterbiNode[] = [];\n        const eos = lattice.nodes_end_at[lattice.nodes_end_at.length - 1][0];\n        let node_back = eos.prev;\n        if (node_back == null) {\n            return [];\n        }\n        while (node_back.type !== \"BOS\") {\n            shortest_path.push(node_back);\n            if (node_back.prev == null) {\n                // TODO Failed to back. Process unknown words?\n                return [];\n            }\n            node_back = node_back.prev;\n        }\n\n        return shortest_path.reverse();\n    }\n}\n\nexport default ViterbiSearcher;\n",
    "import type DynamicDictionaries from \"./dict/DynamicDictionaries\";\nimport type TokenInfoDictionary from \"./dict/TokenInfoDictionary\";\nimport type UnknownDictionary from \"./dict/UnknownDictionary\";\nimport IpadicFormatter, { type TOKEN } from \"./util/IpadicFormatter\";\nimport ViterbiBuilder from \"./viterbi/ViterbiBuilder\";\nimport type ViterbiNode from \"./viterbi/ViterbiNode\";\nimport ViterbiSearcher from \"./viterbi/ViterbiSearcher\";\n\nclass Tokenizer {\n    #token_info_dictionary: TokenInfoDictionary;\n    #unknown_dictionary: UnknownDictionary;\n    #viterbi_builder: ViterbiBuilder;\n    #viterbi_searcher: ViterbiSearcher;\n    #formatter: IpadicFormatter;\n    constructor(dic: DynamicDictionaries) {\n        this.#token_info_dictionary = dic.token_info_dictionary;\n        this.#unknown_dictionary = dic.unknown_dictionary;\n        this.#viterbi_builder = new ViterbiBuilder(dic);\n        this.#viterbi_searcher = new ViterbiSearcher(dic.connection_costs);\n        this.#formatter = new IpadicFormatter(); // TODO Other dictionaries\n    }\n\n    static splitByPunctuation(input: string): string[] {\n        const matches = input.matchAll(/、|。/g);\n        const sentences = [];\n        let lastIndex = 0;\n        for (const match of matches) {\n            const index = match.index;\n            sentences.push(input.slice(lastIndex, index + 1));\n            lastIndex = index + 1;\n        }\n        if (lastIndex < input.length) {\n            sentences.push(input.slice(lastIndex));\n        }\n        return sentences;\n    }\n\n    tokenize(text: string) {\n        const sentences = Tokenizer.splitByPunctuation(text);\n        const tokens: TOKEN[] = [];\n        for (const sentence of sentences) {\n            this.#tokenizeForSentence(sentence, tokens);\n        }\n        return tokens;\n    }\n\n    #tokenizeForSentence(sentence: string, tokens: TOKEN[] = []): TOKEN[] {\n        const lattice = this.#viterbi_builder.build(sentence);\n        const best_path = this.#viterbi_searcher.search(lattice);\n        const last_pos = tokens.length > 0 ? tokens[tokens.length - 1].word_position : 0;\n        for (const node of best_path) {\n            tokens.push(this.#getTokenFromNode(node, last_pos));\n        }\n        return tokens;\n    }\n\n    #getTokenFromNode(node: ViterbiNode, last_pos: number): TOKEN {\n        const features_line =\n            node.type === \"KNOWN\"\n                ? this.#token_info_dictionary.getFeatures(node.name)\n                : this.#unknown_dictionary.getFeatures(node.name);\n\n        const features = features_line ? features_line.split(\",\") : [];\n\n        if (node.type === \"UNKNOWN\") {\n            return this.#formatter.formatUnknownEntry(\n                node.name,\n                last_pos + node.start_pos,\n                node.type,\n                features,\n                node.surface_form\n            );\n        }\n\n        return this.#formatter.formatEntry(node.name, last_pos + node.start_pos, node.type, features);\n    }\n}\n\nexport default Tokenizer;\n",
    "import { existsSync, readFileSync } from \"node:fs\";\nimport path from \"node:path\";\nimport zlib from \"node:zlib\";\nimport DynamicDictionaries from \"../../_core/dict/DynamicDictionaries\";\n\nclass DictionaryLoader {\n    #dic_path: string;\n    constructor(dic_path = \"dict/\") {\n        this.#dic_path = dic_path;\n    }\n\n    #loadArrayBuffer = (file: string) =>\n        new Promise<ArrayBufferLike>((resolve, reject) => {\n            if (!existsSync(file)) return reject(new Error(`${file} does not exist`));\n            const buffer = readFileSync(file);\n            zlib.gunzip(new Uint8Array(buffer), (err, binary) => {\n                if (err) return reject(err);\n                const typed_array = new Uint8Array(binary);\n                resolve(typed_array.buffer);\n            });\n        });\n\n    load(callback: (error: Error | null, dic: DynamicDictionaries) => void) {\n        const dictionaries = new DynamicDictionaries();\n        Promise.all(\n            [\n                // Trie\n                \"base.dat.gz\",\n                \"check.dat.gz\",\n                // Token info dictionaries\n                \"tid.dat.gz\",\n                \"tid_pos.dat.gz\",\n                \"tid_map.dat.gz\",\n                // Connection cost matrix\n                \"cc.dat.gz\",\n                // Unknown dictionaries\n                \"unk.dat.gz\",\n                \"unk_pos.dat.gz\",\n                \"unk_map.dat.gz\",\n                \"unk_char.dat.gz\",\n                \"unk_compat.dat.gz\",\n                \"unk_invoke.dat.gz\",\n            ].map((filename) => this.#loadArrayBuffer(path.join(this.#dic_path, filename)))\n        )\n            .then((buffers) => {\n                // Trie\n                dictionaries.loadTrie(new Int32Array(buffers[0]), new Int32Array(buffers[1]));\n                // Token info dictionaries\n                dictionaries.loadTokenInfoDictionaries(\n                    new Uint8Array(buffers[2]),\n                    new Uint8Array(buffers[3]),\n                    new Uint8Array(buffers[4])\n                );\n                // Connection cost matrix\n                dictionaries.loadConnectionCosts(new Int16Array(buffers[5]));\n                // Unknown dictionaries\n                dictionaries.loadUnknownDictionaries(\n                    new Uint8Array(buffers[6]),\n                    new Uint8Array(buffers[7]),\n                    new Uint8Array(buffers[8]),\n                    new Uint8Array(buffers[9]),\n                    new Uint32Array(buffers[10]),\n                    new Uint8Array(buffers[11])\n                );\n                //// this.#dic.loadUnknownDictionaries(char_buffer, unk_buffer);\n                callback(null, dictionaries);\n            })\n            .catch((error) => {\n                callback(error, dictionaries);\n            });\n    }\n}\n\nexport default DictionaryLoader;\n",
    "import Tokenizer from \"../_core/Tokenizer\";\nimport DictionaryLoader from \"./loader/DictionaryLoader\";\n\nexport type TokenizerBuilderOption = {\n    dicPath?: string | undefined;\n};\n\nclass TokenizerBuilder {\n    #loader: DictionaryLoader;\n\n    constructor(option: TokenizerBuilderOption = {}) {\n        this.#loader = new DictionaryLoader(option.dicPath);\n    }\n\n    build(callback: (err: Error | null, tokenizer: Tokenizer) => void) {\n        this.#loader.load((err, dic) => {\n            callback(err, new Tokenizer(dic));\n        });\n    }\n}\n\nexport default TokenizerBuilder;\n",
    "import DictionaryBuilder from \"../_core/dict/builder/DictionaryBuilder\";\nimport TokenizerBuilder, { type TokenizerBuilderOption } from \"./TokenizerBuilder\";\n\nexport { TokenizerBuilder, type TokenizerBuilderOption, DictionaryBuilder };\n\n// Public methods\nexport default {\n    builder: (option: TokenizerBuilderOption = {}) => {\n        return new TokenizerBuilder(option);\n    },\n    dictionaryBuilder: () => {\n        return new DictionaryBuilder();\n    },\n};\n"
  ],
  "mappings": "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",
  "debugId": "9B643853B2D6809964756E2164756E21",
  "names": []
}