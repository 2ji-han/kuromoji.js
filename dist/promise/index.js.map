{
  "version": 3,
  "sources": ["../src/_core/util/CreateTypedArray.ts", "../src/_core/util/DoubleArray.ts", "../src/_core/dict/ConnectionCosts.ts", "../src/_core/util/ByteBuffer.ts", "../src/_core/dict/TokenInfoDictionary.ts", "../src/_core/util/SurrogateAwareString.ts", "../src/_core/dict/CharacterClass.ts", "../src/_core/dict/InvokeDefinitionMap.ts", "../src/_core/dict/CharacterDefinition.ts", "../src/_core/dict/UnknownDictionary.ts", "../src/_core/dict/DynamicDictionaries.ts", "../src/_core/dict/builder/CharacterDefinitionBuilder.ts", "../src/_core/dict/builder/ConnectionCostsBuilder.ts", "../src/_core/dict/builder/DictionaryBuilder.ts", "../src/_core/util/IpadicFormatter.ts", "../src/_core/viterbi/ViterbiNode.ts", "../src/_core/viterbi/ViterbiLattice.ts", "../src/_core/viterbi/ViterbiBuilder.ts", "../src/_core/viterbi/ViterbiSearcher.ts", "../src/_core/Tokenizer.ts", "../src/promise/loader/DictionaryLoader.ts", "../src/promise/TokenizerBuilder.ts", "../src/promise/kuromoji.ts"],
  "sourcesContent": [
    "export default (signed: boolean, bytes: number, size: number) => {\n    if (signed) {\n        switch (bytes) {\n            case 1:\n                return new Int8Array(size);\n            case 2:\n                return new Int16Array(size);\n            case 4:\n                return new Int32Array(size);\n            default:\n                throw new RangeError(`Invalid parameter: ${bytes}`);\n        }\n    }\n    switch (bytes) {\n        case 1:\n            return new Uint8Array(size);\n        case 2:\n            return new Uint16Array(size);\n        case 4:\n            return new Uint32Array(size);\n        default:\n            throw new RangeError(`Invalid parameter: ${bytes}`);\n    }\n};\n",
    "import createTypedArray from \"./CreateTypedArray\";\n\nconst TERM_CHAR = \"\\u0000\"; // terminal character\nconst TERM_CODE = 0; // terminal character code\nconst ROOT_ID = 0; // index of root node\nconst NOT_FOUND = -1; // traverse() returns if no nodes found\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\ntype ArrayBuffer = Uint8Array | Int8Array | Int16Array | Int32Array | Uint16Array | Uint32Array;\n\ntype BaseCheck = {\n    signed: boolean;\n    bytes: number;\n    array: ArrayBuffer;\n};\n\nclass BufferController {\n    #first_unused_node: number;\n    #base: BaseCheck;\n    #check: BaseCheck;\n\n    constructor(initial_size = 1024) {\n        this.#first_unused_node = ROOT_ID + 1;\n\n        this.#base = {\n            signed: true,\n            bytes: 4,\n            array: createTypedArray(true, 4, initial_size),\n        };\n\n        this.#check = {\n            signed: true,\n            bytes: 4,\n            array: createTypedArray(true, 4, initial_size),\n        };\n\n        // Initialize root node\n        this.#base.array[ROOT_ID] = 1;\n        this.#check.array[ROOT_ID] = ROOT_ID;\n\n        // Initialize BASE and CHECK arrays\n        this.#initBase(this.#base.array, ROOT_ID + 1, this.#base.array.length);\n        this.#initCheck(this.#check.array, ROOT_ID + 1, this.#check.array.length);\n    }\n\n    #initBase(_base: ArrayBuffer, start: number, end: number) {\n        for (let i = start; i < end; i++) {\n            _base[i] = -i + 1;\n        }\n        if (0 < this.#check.array[this.#check.array.length - 1]) {\n            let last_used_id = this.#check.array.length - 2;\n            while (0 < this.#check.array[last_used_id]) {\n                last_used_id--;\n            }\n            _base[start] = -last_used_id;\n        }\n    }\n\n    #initCheck(_check: ArrayBuffer, start: number, end: number) {\n        for (let i = start; i < end; i++) {\n            _check[i] = -i - 1;\n        }\n    }\n\n    #realloc(min_size: number) {\n        const new_size = min_size * 2;\n        const base_new_array = createTypedArray(this.#base.signed, this.#base.bytes, new_size);\n        this.#initBase(base_new_array, this.#base.array.length, new_size);\n        base_new_array.set(this.#base.array);\n        this.#base.array = base_new_array;\n\n        const check_new_array = createTypedArray(this.#check.signed, this.#check.bytes, new_size);\n        this.#initCheck(check_new_array, this.#check.array.length, new_size);\n        check_new_array.set(this.#check.array);\n        this.#check.array = check_new_array;\n    }\n\n    getBaseBuffer() {\n        return this.#base.array;\n    }\n\n    getCheckBuffer() {\n        return this.#check.array;\n    }\n\n    loadBaseBuffer(base_buffer: ArrayBuffer) {\n        this.#base.array = base_buffer;\n        return this;\n    }\n\n    loadCheckBuffer(check_buffer: ArrayBuffer) {\n        this.#check.array = check_buffer;\n        return this;\n    }\n\n    size() {\n        return Math.max(this.#base.array.length, this.#check.array.length);\n    }\n\n    getBase(index: number) {\n        if (this.#base.array.length - 1 < index) {\n            return -index + 1;\n        }\n        return this.#base.array[index];\n    }\n\n    getCheck(index: number) {\n        if (this.#check.array.length - 1 < index) {\n            return -index - 1;\n        }\n        return this.#check.array[index];\n    }\n\n    setBase(index: number, base_value: number) {\n        if (this.#base.array.length - 1 < index) {\n            this.#realloc(index);\n        }\n        this.#base.array[index] = base_value;\n    }\n\n    setCheck(index: number, check_value: number) {\n        if (this.#check.array.length - 1 < index) {\n            this.#realloc(index);\n        }\n        this.#check.array[index] = check_value;\n    }\n\n    setFirstUnusedNode(index: number) {\n        this.#first_unused_node = index;\n    }\n\n    getFirstUnusedNode() {\n        return this.#first_unused_node;\n    }\n\n    shrink() {\n        let last_index = Math.max(this.#base.array.length, this.#check.array.length) - 1;\n        while (0 <= this.#check.array[last_index]) {\n            last_index--;\n        }\n        this.#base.array = this.#base.array.subarray(0, last_index + 2);\n        this.#check.array = this.#check.array.subarray(0, last_index + 2);\n    }\n\n    calc() {\n        let unused_count = 0;\n        const size = this.#check.array.length;\n        for (let i = 0; i < size; i++) {\n            if (this.#check.array[i] < 0) {\n                unused_count++;\n            }\n        }\n        return {\n            all: size,\n            unused: unused_count,\n            efficiency: (size - unused_count) / size,\n        };\n    }\n\n    dump() {\n        let dump_base = \"\";\n        let dump_check = \"\";\n\n        for (const data of this.#base.array) {\n            dump_base += ` ${data}`;\n        }\n        for (const data of this.#check.array) {\n            dump_check += ` ${data}`;\n        }\n\n        console.log(`base:${dump_base}`);\n        console.log(`check:${dump_check}`);\n\n        return `base:${dump_base} check:${dump_check}`;\n    }\n}\n\n/**\n * Factory method of double array\n */\nclass DoubleArrayBuilder {\n    #bufferController: BufferController;\n    #keys: { k: string | Uint8Array; v: number }[];\n    constructor(initial_size = 1024) {\n        this.#bufferController = new BufferController(initial_size); // BASE and CHECK\n        this.#keys = [];\n    }\n\n    /**\n     * Append a key to initialize set\n     * (This method should be called by dictionary ordered key)\n     *\n     * @param {String} key\n     * @param {Number} value Integer value from 0 to max signed integer number - 1\n     */\n    append(key: string, record: number) {\n        this.#keys.push({ k: key, v: record });\n        return this;\n    }\n\n    /**\n     * Build double array for given keys\n     *\n     * @param {Array} keys Array of keys. A key is a Object which has properties 'k', 'v'.\n     * 'k' is a key string, 'v' is a record assigned to that key.\n     * @return {DoubleArray} Compiled double array\n     */\n    build(keys: { k: string | Uint8Array; v: number }[] = this.#keys, sorted = false) {\n        if (keys == null) {\n            return new DoubleArray(this.#bufferController);\n        }\n        // Convert key string to ArrayBuffer\n        const buff_keys: { k: Uint8Array; v: number }[] | null = keys.map((k) => {\n            return {\n                k: encoder.encode(k.k + TERM_CHAR),\n                v: k.v,\n            };\n        });\n\n        // Sort keys by byte order\n        if (sorted) {\n            this.#keys = buff_keys;\n        } else {\n            this.#keys = buff_keys.sort((k1, k2) => {\n                const b1 = k1.k;\n                const b2 = k2.k;\n                const min_length = Math.min(b1.length, b2.length);\n                for (let pos = 0; pos < min_length; pos++) {\n                    if (b1[pos] === b2[pos]) {\n                        continue;\n                    }\n                    return b1[pos] - b2[pos];\n                }\n                return b1.length - b2.length;\n            });\n        }\n\n        this.#_build(ROOT_ID, 0, 0, this.#keys.length);\n        return new DoubleArray(this.#bufferController);\n    }\n\n    /**\n     * Append nodes to BASE and CHECK array recursively\n     */\n    #_build(parent_index: number, position: number, start: number, length: number) {\n        const children_info = this.#getChildrenInfo(position, start, length);\n        const _base = this.#findAllocatableBase(children_info);\n\n        this.#setBufferController(parent_index, children_info, _base);\n\n        for (let i = 0; i < children_info.length; i = i + 3) {\n            const child_code = children_info[i];\n            if (child_code === TERM_CODE) {\n                continue;\n            }\n            const child_start = children_info[i + 1];\n            const child_len = children_info[i + 2];\n            const child_index = _base + child_code;\n            this.#_build(child_index, position + 1, child_start, child_len);\n        }\n    }\n\n    #getChildrenInfo(position: number, start: number, length: number) {\n        let current_char = this.#keys[start].k[position];\n        let children_info = new Int32Array(length * 3);\n        let i = 0;\n        children_info[i++] = Number.parseInt(`${current_char}`); // char (current)\n        children_info[i++] = start; // start index (current)\n\n        let next_pos = start;\n        let start_pos = start;\n        for (; next_pos < start + length; next_pos++) {\n            const next_char = this.#keys[next_pos].k[position];\n            if (current_char !== next_char) {\n                children_info[i++] = next_pos - start_pos; // length (current)\n\n                children_info[i++] = Number.parseInt(`${next_char}`); // char (next)\n                children_info[i++] = next_pos; // start index (next)\n                current_char = next_char;\n                start_pos = next_pos;\n            }\n        }\n        children_info[i++] = next_pos - start_pos;\n        children_info = children_info.subarray(0, i);\n\n        return children_info;\n    }\n\n    #setBufferController(parent_id: number, children_info: Int32Array, _base: number) {\n        const bufferController = this.#bufferController;\n        bufferController.setBase(parent_id, _base); // Update BASE of parent node\n        for (let i = 0; i < children_info.length; i = i + 3) {\n            const code = children_info[i];\n            const child_id = _base + code;\n\n            // Update linked list of unused nodes\n\n            // Assertion\n            // if (child_id < 0) {\n            //     throw 'assertion error: child_id is negative'\n            // }\n\n            const prev_unused_id = -bufferController.getBase(child_id);\n            const next_unused_id = -bufferController.getCheck(child_id);\n            // if (prev_unused_id < 0) {\n            //     throw 'assertion error: setBC'\n            // }\n            // if (next_unused_id < 0) {\n            //     throw 'assertion error: setBC'\n            // }\n            if (child_id !== bufferController.getFirstUnusedNode()) {\n                bufferController.setCheck(prev_unused_id, -next_unused_id);\n            } else {\n                // Update first_unused_node\n                bufferController.setFirstUnusedNode(next_unused_id);\n            }\n            bufferController.setBase(next_unused_id, -prev_unused_id);\n\n            const check = parent_id; // CHECK is parent node index\n            bufferController.setCheck(child_id, check); // Update CHECK of child node\n\n            // Update record\n            if (code === TERM_CODE) {\n                const start_pos = children_info[i + 1];\n                // var len = children_info[i + 2];\n                // if (len != 1) {\n                //     throw 'assertion error: there are multiple terminal nodes. len:' + len;\n                // }\n                let value = this.#keys[start_pos].v;\n\n                if (value == null) {\n                    value = 0;\n                }\n\n                const base = -value - 1; // BASE is inverted record value\n                bufferController.setBase(child_id, base); // Update BASE of child(leaf) node\n            }\n        }\n    }\n\n    /**\n     * Find BASE value that all children are allocatable in double array's region\n     */\n    #findAllocatableBase(children_info: Int32Array) {\n        const bufferController = this.#bufferController;\n\n        // Assertion: keys are sorted by byte order\n        // var c = -1;\n        // for (var i = 0; i < children_info.length; i = i + 3) {\n        //     if (children_info[i] < c) {\n        //         throw 'assertion error: not sort key'\n        //     }\n        //     c = children_info[i];\n        // }\n\n        // iterate linked list of unused nodes\n        let _base: number;\n        let curr = bufferController.getFirstUnusedNode(); // current index\n        // if (curr < 0) {\n        //     throw 'assertion error: getFirstUnusedNode returns negative value'\n        // }\n\n        while (true) {\n            _base = curr - children_info[0];\n\n            if (_base < 0) {\n                curr = -bufferController.getCheck(curr); // next\n\n                // if (curr < 0) {\n                //     throw 'assertion error: getCheck returns negative value'\n                // }\n\n                continue;\n            }\n\n            let empty_area_found = true;\n            for (let i = 0; i < children_info.length; i = i + 3) {\n                const code = children_info[i];\n                const candidate_id = _base + code;\n\n                if (!this.#isUnusedNode(candidate_id)) {\n                    // candidate_id is used node\n                    // next\n                    curr = -bufferController.getCheck(curr);\n                    // if (curr < 0) {\n                    //     throw 'assertion error: getCheck returns negative value'\n                    // }\n\n                    empty_area_found = false;\n                    break;\n                }\n            }\n            if (empty_area_found) {\n                // Area is free\n                return _base;\n            }\n        }\n    }\n\n    /**\n     * Check this double array index is unused or not\n     */\n    #isUnusedNode(index: number) {\n        const bufferController = this.#bufferController;\n        const check = bufferController.getCheck(index);\n\n        // if (index < 0) {\n        //     throw 'assertion error: isUnusedNode index:' + index;\n        // }\n\n        if (index === ROOT_ID) {\n            // root node\n            return false;\n        }\n        if (check < 0) {\n            // unused\n            return true;\n        }\n\n        // used node (incl. leaf)\n        return false;\n    }\n}\n\n/**\n * Factory method of double array\n */\nclass DoubleArray {\n    #bufferController: BufferController;\n    constructor(bufferController: BufferController) {\n        this.#bufferController = bufferController; // BASE and CHECK\n        this.#bufferController.shrink();\n    }\n\n    /**\n     * Look up a given key in this trie\n     *\n     * @param {String} key\n     * @return {Boolean} True if this trie contains a given key\n     */\n    contain(_key: string) {\n        let key = _key;\n        const bufferController = this.#bufferController;\n        key += TERM_CHAR;\n        const buffer = encoder.encode(key);\n        let parent = ROOT_ID;\n        let child = NOT_FOUND;\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n\n            child = this.#traverse(parent, code);\n            if (child === NOT_FOUND) {\n                return false;\n            }\n\n            if (bufferController.getBase(child) <= 0) {\n                // leaf node\n                return true;\n            }\n            // not leaf\n            parent = child;\n        }\n        return false;\n    }\n\n    /**\n     * Look up a given key in this trie\n     *\n     * @param {String} key\n     * @return {Number} Record value assgned to this key, -1 if this key does not contain\n     */\n    lookup(_key: string) {\n        let key = _key;\n        key += TERM_CHAR;\n        const buffer = encoder.encode(key);\n        let parent = ROOT_ID;\n        let child = NOT_FOUND;\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            child = this.#traverse(parent, code);\n            if (child === NOT_FOUND) {\n                return NOT_FOUND;\n            }\n            parent = child;\n        }\n        const base = this.#bufferController.getBase(child);\n        if (base <= 0) {\n            // leaf node\n            return -base - 1;\n        }\n        // not leaf\n        return NOT_FOUND;\n    }\n\n    /**\n     * Common prefix search\n     *\n     * @param {String} key\n     * @return {Array} Each result object has 'k' and 'v' (key and record,\n     * respectively) properties assigned to matched string\n     */\n    commonPrefixSearch(key: string): { k: string; v: number }[] {\n        const buffer = encoder.encode(key);\n        const result: { k: string; v: number }[] = [];\n        let parent = ROOT_ID;\n        let child = NOT_FOUND;\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            child = this.#traverse(parent, code);\n            if (child !== NOT_FOUND) {\n                parent = child;\n                // look forward by terminal character code to check this node is a leaf or not\n                const grand_child = this.#traverse(child, TERM_CODE);\n                if (grand_child !== NOT_FOUND) {\n                    const base = this.#bufferController.getBase(grand_child);\n                    const r: { k: string; v: number } = {\n                        k: \"\",\n                        v: 0,\n                    };\n\n                    if (base <= 0) {\n                        // If child is a leaf node, add record to result\n                        r.v = -base - 1;\n                    }\n                    // If child is a leaf node, add word to result\n                    r.k = decoder.decode(buffer.slice(0, i + 1));\n                    result.push(r);\n                }\n                continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    #traverse(parent: number, code: number) {\n        const child = this.#bufferController.getBase(parent) + code;\n        if (this.#bufferController.getCheck(child) === parent) {\n            return child;\n        }\n        return NOT_FOUND;\n    }\n\n    size() {\n        return this.#bufferController.size();\n    }\n\n    calc() {\n        return this.#bufferController.calc();\n    }\n\n    dump() {\n        return this.#bufferController.dump();\n    }\n}\n\nexport { DoubleArrayBuilder, DoubleArray };\n\nexport default {\n    builder: (initial_size = 1024) => {\n        return new DoubleArrayBuilder(initial_size);\n    },\n    load: (base_buffer: ArrayBuffer, check_buffer: ArrayBuffer) => {\n        const bufferController = new BufferController(0);\n        bufferController.loadBaseBuffer(base_buffer);\n        bufferController.loadCheckBuffer(check_buffer);\n        return new DoubleArray(bufferController);\n    },\n};\n",
    "class ConnectionCosts {\n    forward_dimension: number;\n    backward_dimension: number;\n    #buffer: Int16Array;\n    constructor(forward_dimension: number, backward_dimension: number) {\n        this.forward_dimension = forward_dimension;\n        this.backward_dimension = backward_dimension;\n\n        // leading 2 integers for forward_dimension, backward_dimension, respectively\n        this.#buffer = new Int16Array(forward_dimension * backward_dimension + 2);\n        this.#buffer[0] = forward_dimension;\n        this.#buffer[1] = backward_dimension;\n    }\n\n    put(forward_id: number, backward_id: number, cost: number) {\n        const index = forward_id * this.backward_dimension + backward_id + 2;\n        if (this.#buffer.length < index + 1) {\n            throw \"ConnectionCosts buffer overflow\";\n        }\n        this.#buffer[index] = cost;\n    }\n\n    get(forward_id: number, backward_id: number) {\n        const index = forward_id * this.backward_dimension + backward_id + 2;\n        if (this.#buffer.length < index + 1) {\n            throw \"ConnectionCosts buffer overflow\";\n        }\n        return this.#buffer[index];\n    }\n\n    loadConnectionCosts(connection_costs_buffer: Int16Array) {\n        this.forward_dimension = connection_costs_buffer[0];\n        this.backward_dimension = connection_costs_buffer[1];\n        this.#buffer = connection_costs_buffer;\n    }\n}\n\nexport default ConnectionCosts;\n",
    "const encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nclass ByteBuffer {\n    #_buffer: Uint8Array;\n    #_position = 0;\n\n    get buffer() {\n        return this.#_buffer;\n    }\n\n    set buffer(value) {\n        this.#_buffer = value;\n    }\n\n    get position() {\n        return this.#_position;\n    }\n\n    set position(value) {\n        this.#_position = value;\n    }\n\n    constructor(arg?: number | Uint8Array) {\n        if (arg === undefined) {\n            this.#_buffer = new Uint8Array(1024 * 1024);\n            this.#_position = 0;\n        } else if (typeof arg === \"number\") {\n            this.#_buffer = new Uint8Array(arg);\n            this.#_position = 0;\n        } else if (arg instanceof Uint8Array) {\n            this.#_buffer = arg;\n            this.#_position = 0; // Overwrite\n        } else {\n            // typeof arg -> String\n            throw `${typeof arg} is invalid parameter type`;\n        }\n    }\n\n    size() {\n        return this.#_buffer.length;\n    }\n\n    reallocate() {\n        const new_array = new Uint8Array(this.#_buffer.length * 2);\n        new_array.set(this.#_buffer);\n        this.#_buffer = new_array;\n    }\n\n    shrink() {\n        this.#_buffer = this.#_buffer.subarray(0, this.#_position);\n        return this.#_buffer;\n    }\n\n    put(b: number | boolean) {\n        if (this.#_buffer.length < this.#_position + 1) {\n            this.reallocate();\n        }\n        if (typeof b === \"boolean\") {\n            this.#_buffer[this.#_position++] = b ? 1 : 0;\n        } else {\n            this.#_buffer[this.#_position++] = b;\n        }\n    }\n\n    get(_index: number | null = null) {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 1;\n        }\n        if (this.#_buffer.length < index + 1) {\n            return 0;\n        }\n        return this.#_buffer[index];\n    }\n\n    // Write short to buffer by little endian\n    putShort(num: number) {\n        if (0xffff < num) {\n            throw `${num} is over short value`;\n        }\n        const lower = 0x00ff & num;\n        const upper = (0xff00 & num) >> 8;\n        this.put(lower);\n        this.put(upper);\n    }\n\n    // Read short from buffer by little endian\n    getShort(_index: number | null) {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 2;\n        }\n        if (this.#_buffer.length < index + 2) {\n            return 0;\n        }\n        const lower = this.#_buffer[index];\n        const upper = this.#_buffer[index + 1];\n        let value = (upper << 8) + lower;\n        if (value & 0x8000) {\n            value = -((value - 1) ^ 0xffff);\n        }\n        return value;\n    }\n\n    // Write integer to buffer by little endian\n    putInt(num: number) {\n        if (0xffffffff < num) {\n            throw `${num} is over integer value`;\n        }\n        const b0 = 0x000000ff & num;\n        const b1 = (0x0000ff00 & num) >> 8;\n        const b2 = (0x00ff0000 & num) >> 16;\n        const b3 = (0xff000000 & num) >> 24;\n        this.put(b0);\n        this.put(b1);\n        this.put(b2);\n        this.put(b3);\n    }\n\n    // Read integer from buffer by little endian\n    getInt(_index: number | null = null) {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 4;\n        }\n        if (this.#_buffer.length < index + 4) {\n            return 0;\n        }\n        const b0 = this.#_buffer[index];\n        const b1 = this.#_buffer[index + 1];\n        const b2 = this.#_buffer[index + 2];\n        const b3 = this.#_buffer[index + 3];\n\n        return (b3 << 24) + (b2 << 16) + (b1 << 8) + b0;\n    }\n\n    readInt() {\n        const pos = this.#_position;\n        this.#_position += 4;\n        return this.getInt(pos);\n    }\n\n    putString(str: string) {\n        const bytes = encoder.encode(str);\n        for (const byte of bytes) {\n            this.put(byte);\n        }\n        // put null character as terminal character\n        this.put(0);\n    }\n\n    getString(_index: number = this.#_position) {\n        let index = _index;\n        const buf = [];\n        let ch: number;\n\n        while (index < this.#_buffer.length) {\n            ch = this.get(index++);\n            if (ch === 0) break;\n            buf.push(ch);\n        }\n\n        this.#_position = index;\n        return decoder.decode(new Uint8Array(buf));\n    }\n\n    getUtf32(_index: number | null = null): number {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 4;\n        }\n        if (this.#_buffer.length < index + 4) {\n            return 0;\n        }\n        const codePoint = this.#_buffer.subarray(index, index + 4);\n        return new DataView(codePoint.buffer).getUint32(0, false); // little-endian\n    }\n\n    getBool(_index: number | null = null) {\n        let index = _index;\n        if (index == null) {\n            index = this.#_position;\n            this.#_position += 1;\n        }\n        if (this.#_buffer.length < index + 1) {\n            return false;\n        }\n        return Boolean(this.#_buffer[index]);\n    }\n}\n\nexport default ByteBuffer;\n",
    "import ByteBuffer from \"../../_core/util/ByteBuffer\";\n\nclass TokenInfoDictionary {\n    dictionary: ByteBuffer;\n    target_map: Map<number, number[]>;\n    pos_buffer: ByteBuffer;\n    constructor() {\n        this.dictionary = new ByteBuffer(10 * 1024 * 1024);\n        this.target_map = new Map<number, number[]>(); // trie_id (of surface form) -> token_info_id (of token)\n        this.pos_buffer = new ByteBuffer(10 * 1024 * 1024);\n    }\n\n    // left_id right_id word_cost ...\n    // ^ this position is token_info_id\n    buildDictionary(entries: string[][]): { [word_id: number]: string } {\n        const dictionary_entries: { [word_id: number]: string } = {}; // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n        for (let i = 0; i < entries.length; i++) {\n            const entry = entries[i];\n            if (entry.length < 4) {\n                continue;\n            }\n            const surface_form = entry[0];\n            const left_id = Number.parseInt(entry[1]);\n            const right_id = Number.parseInt(entry[2]);\n            const word_cost = Number.parseInt(entry[3]);\n            const feature = entry.slice(4).join(\",\"); // TODO Optimize\n            // Assertion\n            if (!Number.isFinite(left_id) || !Number.isFinite(right_id) || !Number.isFinite(word_cost)) {\n                console.log(entry);\n            }\n            const token_info_id = this.put(left_id, right_id, word_cost, surface_form, feature);\n            dictionary_entries[token_info_id] = surface_form;\n        }\n\n        // Remove last unused area\n        this.dictionary.shrink();\n        this.pos_buffer.shrink();\n\n        return dictionary_entries;\n    }\n\n    put(left_id: number, right_id: number, word_cost: number, surface_form: string, feature: string): number {\n        const token_info_id = this.dictionary.position;\n        const pos_id = this.pos_buffer.position;\n\n        this.dictionary.putShort(left_id);\n        this.dictionary.putShort(right_id);\n        this.dictionary.putShort(word_cost);\n        this.dictionary.putInt(pos_id);\n        this.pos_buffer.putString(`${surface_form},${feature}`);\n\n        return token_info_id;\n    }\n\n    addMapping(source: number, target: number): void {\n        let mapping = this.target_map.get(source);\n        if (mapping == null) {\n            mapping = [];\n        }\n        mapping.push(target);\n\n        this.target_map.set(source, mapping);\n    }\n\n    targetMapToBuffer(): Uint8Array {\n        const buffer = new ByteBuffer();\n        buffer.putInt(Object.keys(this.target_map).length);\n        for (const _key in this.target_map) {\n            const key = Number.parseInt(_key);\n\n            const values = this.target_map.get(key); // Array\n            if (!values) continue;\n\n            const map_values_size = values.length;\n            buffer.putInt(key);\n            buffer.putInt(map_values_size);\n            for (const value of values) {\n                buffer.putInt(value);\n            }\n        }\n        return buffer.shrink(); // Shrink-ed Typed Array\n    }\n\n    // from tid.dat\n    loadDictionary(array_buffer: Uint8Array) {\n        this.dictionary = new ByteBuffer(array_buffer);\n        return this;\n    }\n\n    // from tid_pos.dat\n    loadPosVector(array_buffer: Uint8Array) {\n        this.pos_buffer = new ByteBuffer(array_buffer);\n        return this;\n    }\n\n    // from tid_map.dat\n    loadTargetMap(array_buffer: Uint8Array) {\n        const buffer = new ByteBuffer(array_buffer);\n        buffer.position = 0;\n        this.target_map = new Map<number, number[]>();\n        buffer.readInt(); // map_keys_size\n        while (true) {\n            if (buffer.buffer.length < buffer.position + 1) {\n                break;\n            }\n            const key = buffer.readInt();\n            const map_values_size = buffer.readInt();\n            for (let i = 0; i < map_values_size; i++) {\n                const value = buffer.readInt();\n                this.addMapping(key, value);\n            }\n        }\n        return this;\n    }\n\n    getFeatures(token_info_id: number): string | null {\n        if (Number.isNaN(token_info_id)) {\n            return null;\n        }\n        const pos_id = this.dictionary.getInt(token_info_id + 6);\n        return this.pos_buffer.getString(pos_id);\n    }\n}\n\nexport default TokenInfoDictionary;\n",
    "class SurrogateAwareString {\n    #str: string;\n    #index_mapping: number[];\n    length: number;\n    /**\n     * String wrapper for UTF-16 surrogate pair (4 bytes)\n     * @param {string} str String to wrap\n     * @constructor\n     */\n    constructor(str: string) {\n        this.#str = str;\n        this.#index_mapping = [];\n        for (let pos = 0; pos < str.length; pos++) {\n            const ch = str.charAt(pos);\n            this.#index_mapping.push(pos);\n            if (SurrogateAwareString.isSurrogatePair(ch)) {\n                pos++;\n            }\n        }\n        // Surrogate aware length\n        this.length = this.#index_mapping.length;\n    }\n\n    slice(index: number) {\n        if (this.#index_mapping.length <= index) {\n            return \"\";\n        }\n        const surrogate_aware_index = this.#index_mapping[index];\n        return this.#str.slice(surrogate_aware_index);\n    }\n\n    charAt(index: number) {\n        if (this.#str.length <= index) {\n            return \"\";\n        }\n        const surrogate_aware_start_index = this.#index_mapping[index];\n        const surrogate_aware_end_index = this.#index_mapping[index + 1];\n        if (surrogate_aware_end_index == null) {\n            return this.#str.slice(surrogate_aware_start_index);\n        }\n        return this.#str.slice(surrogate_aware_start_index, surrogate_aware_end_index);\n    }\n\n    charCodeAt(index: number) {\n        if (this.#index_mapping.length <= index) {\n            return Number.NaN;\n        }\n        const surrogate_aware_index = this.#index_mapping[index];\n        const upper = this.#str.charCodeAt(surrogate_aware_index);\n        let lower: number;\n        if (upper >= 0xd800 && upper <= 0xdbff && surrogate_aware_index < this.#str.length) {\n            lower = this.#str.charCodeAt(surrogate_aware_index + 1);\n            if (lower >= 0xdc00 && lower <= 0xdfff) {\n                return (upper - 0xd800) * 0x400 + lower - 0xdc00 + 0x10000;\n            }\n        }\n        return upper;\n    }\n\n    toString() {\n        return this.#str;\n    }\n\n    add(other: SurrogateAwareString): SurrogateAwareString {\n        return new SurrogateAwareString(this.#str + other.#str);\n    }\n\n    append(str: string): SurrogateAwareString {\n        return new SurrogateAwareString(this.#str + str);\n    }\n\n    static isSurrogatePair(ch: string) {\n        const utf16_code = ch.charCodeAt(0);\n        if (utf16_code >= 0xd800 && utf16_code <= 0xdbff) {\n            // surrogate pair\n            return true;\n        }\n        return false;\n    }\n}\n\nexport default SurrogateAwareString;\n",
    "class CharacterClass {\n    class_id: number;\n    class_name: string;\n    is_always_invoke: boolean;\n    is_grouping: boolean;\n    max_length: number;\n    /**\n     * CharacterClass\n     * @param {number} class_id\n     * @param {string} class_name\n     * @param {boolean} is_always_invoke\n     * @param {boolean} is_grouping\n     * @param {number} max_length\n     * @constructor\n     */\n    constructor(\n        class_id: number,\n        class_name: string,\n        is_always_invoke: boolean,\n        is_grouping: boolean,\n        max_length: number\n    ) {\n        this.class_id = class_id;\n        this.class_name = class_name;\n        this.is_always_invoke = is_always_invoke;\n        this.is_grouping = is_grouping;\n        this.max_length = max_length;\n    }\n}\n\nexport default CharacterClass;\n",
    "import ByteBuffer from \"../../_core/util/ByteBuffer\";\nimport CharacterClass from \"./CharacterClass\";\n\n/**\n * InvokeDefinitionMap represents invoke definition a part of char.def\n * @constructor\n */\nclass InvokeDefinitionMap {\n    #map: CharacterClass[];\n    #lookup_table: Map<string, number>;\n    constructor() {\n        this.#map = [];\n        this.#lookup_table = new Map<string, number>(); // Just for building dictionary\n    }\n\n    /**\n     * Load InvokeDefinitionMap from buffer\n     * @param {Uint8Array} invoke_def_buffer\n     * @returns {InvokeDefinitionMap}\n     */\n    static load(invoke_def_buffer: Uint8Array): InvokeDefinitionMap {\n        const invoke_def = new InvokeDefinitionMap();\n        const character_category_definition: CharacterClass[] = [];\n\n        const buffer = new ByteBuffer(invoke_def_buffer);\n        while (buffer.position + 1 < buffer.size()) {\n            const is_always_invoke = buffer.getBool();\n            const is_grouping = buffer.getBool();\n            const max_length = buffer.getInt();\n            const class_name = buffer.getString();\n            character_category_definition.push(\n                new CharacterClass(\n                    character_category_definition.length,\n                    class_name,\n                    is_always_invoke,\n                    is_grouping,\n                    max_length\n                )\n            );\n        }\n\n        invoke_def.init(character_category_definition);\n\n        return invoke_def;\n    }\n\n    /**\n     * Initializing method\n     * @param {Array.<CharacterClass>} character_category_definition Array of CharacterClass\n     */\n    init(character_category_definition: CharacterClass[]) {\n        if (character_category_definition == null) {\n            return;\n        }\n        const ccd_length = character_category_definition.length;\n        for (let i = 0; i < ccd_length; i++) {\n            const character_class = character_category_definition[i];\n            this.#map[i] = character_class;\n            this.#lookup_table.set(character_class.class_name, i);\n        }\n    }\n\n    /**\n     * Get class information by class ID\n     * @param {number} class_id\n     * @returns {CharacterClass}\n     */\n    getCharacterClass(class_id: number) {\n        return this.#map[class_id];\n    }\n\n    /**\n     * For building character definition dictionary\n     * @param {string} class_name character\n     * @returns {number} class_id\n     */\n    lookup(class_name: string): number | null {\n        const class_id = this.#lookup_table.get(class_name);\n        if (class_id == null) {\n            return null;\n        }\n        return class_id;\n    }\n\n    /**\n     * Transform from map to binary buffer\n     * @returns {Uint8Array}\n     */\n    toBuffer() {\n        const buffer = new ByteBuffer();\n        for (let i = 0; i < this.#map.length; i++) {\n            const char_class = this.#map[i];\n            buffer.put(char_class.is_always_invoke);\n            buffer.put(char_class.is_grouping);\n            buffer.putInt(char_class.max_length);\n            buffer.putString(char_class.class_name);\n        }\n        buffer.shrink();\n        return buffer.buffer;\n    }\n}\n\nexport default InvokeDefinitionMap;\n",
    "import SurrogateAwareString from \"../../_core/util/SurrogateAwareString\";\nimport CharacterClass from \"./CharacterClass\";\nimport InvokeDefinitionMap from \"./InvokeDefinitionMap\";\n\nconst DEFAULT_CATEGORY = \"DEFAULT\";\n\nclass CharacterDefinition {\n    character_category_map: Uint8Array;\n    compatible_category_map: Uint32Array;\n    invoke_definition_map: null | InvokeDefinitionMap;\n    /**\n     * CharacterDefinition represents char.def file and\n     * defines behavior of unknown word processing\n     * @constructor\n     */\n    constructor() {\n        this.character_category_map = new Uint8Array(65536); // for all UCS2 code points\n        this.compatible_category_map = new Uint32Array(65536); // for all UCS2 code points\n        this.invoke_definition_map = null;\n    }\n\n    /**\n     * Load CharacterDefinition\n     * @param {Uint8Array} cat_map_buffer\n     * @param {Uint32Array} compat_cat_map_buffer\n     * @param {Uint8Array} invoke_def_buffer\n     * @returns {CharacterDefinition}\n     */\n    load(cat_map_buffer: Uint8Array, compat_cat_map_buffer: Uint32Array, invoke_def_buffer: Uint8Array) {\n        const char_def = new CharacterDefinition();\n        char_def.character_category_map = cat_map_buffer;\n        char_def.compatible_category_map = compat_cat_map_buffer;\n        char_def.invoke_definition_map = InvokeDefinitionMap.load(invoke_def_buffer);\n        return char_def;\n    }\n\n    static parseCharCategory(class_id: number, parsed_category_def: RegExpExecArray) {\n        const category = parsed_category_def[1];\n        const invoke = Number.parseInt(parsed_category_def[2]);\n        const grouping = Number.parseInt(parsed_category_def[3]);\n        const max_length = Number.parseInt(parsed_category_def[4]);\n        if (!Number.isFinite(invoke) || (invoke !== 0 && invoke !== 1)) {\n            console.log(`char.def parse error. INVOKE is 0 or 1 in:${invoke}`);\n            return null;\n        }\n        if (!Number.isFinite(grouping) || (grouping !== 0 && grouping !== 1)) {\n            console.log(`char.def parse error. GROUP is 0 or 1 in:${grouping}`);\n            return null;\n        }\n        if (!Number.isFinite(max_length) || max_length < 0) {\n            console.log(`char.def parse error. LENGTH is 1 to n:${max_length}`);\n            return null;\n        }\n        return new CharacterClass(class_id, category, invoke === 1, grouping === 1, max_length);\n    }\n\n    static parseCategoryMapping(parsed_category_mapping: RegExpExecArray) {\n        const start = Number.parseInt(parsed_category_mapping[1]);\n        if (!Number.isFinite(start) || start < 0 || start > 0xffff) {\n            console.log(`char.def parse error. CODE is invalid:${start}`);\n        }\n        return {\n            start: start,\n            default: parsed_category_mapping[2],\n            compatible: 3 < parsed_category_mapping.length ? parsed_category_mapping.slice(3) : [],\n        };\n    }\n\n    static parseRangeCategoryMapping(parsed_category_mapping: RegExpExecArray) {\n        const start = Number.parseInt(parsed_category_mapping[1]);\n        const end = Number.parseInt(parsed_category_mapping[2]);\n        if (!Number.isFinite(start) || start < 0 || start > 0xffff) {\n            console.log(`char.def parse error. CODE is invalid:${start}`);\n        }\n        if (!Number.isFinite(end) || end < 0 || end > 0xffff) {\n            console.log(`char.def parse error. CODE is invalid:${end}`);\n        }\n        return {\n            start: start,\n            end: end,\n            default: parsed_category_mapping[3],\n            compatible: 4 < parsed_category_mapping.length ? parsed_category_mapping.slice(4) : [],\n        };\n    }\n\n    /**\n     * Initializing method\n     * @param {Array} category_mapping Array of category mapping\n     */\n    initCategoryMappings(category_mapping: { start: number; end?: number; default: string; compatible: string[] }[]) {\n        if (!this.invoke_definition_map) {\n            throw new Error(\"CharacterDefinition.initCategoryMappings: invoke_definition_map is null\");\n        }\n        // Initialize map by DEFAULT class\n        let code_point = 0;\n        if (category_mapping != null) {\n            const category_mapping_length = category_mapping.length;\n            for (let i = 0; i < category_mapping_length; i++) {\n                const mapping = category_mapping[i];\n                for (code_point = mapping.start; code_point <= (mapping.end || mapping.start); code_point++) {\n                    // Default Category class ID\n                    const id = this.invoke_definition_map.lookup(mapping.default);\n                    if (id == null) {\n                        throw new Error(\n                            \"CharacterDefinition.initCategoryMappings: invoke_definition_map.lookup() returns null\"\n                        );\n                    }\n                    this.character_category_map[code_point] = id;\n\n                    for (let j = 0; j < mapping.compatible.length; j++) {\n                        let bitset = this.compatible_category_map[code_point];\n                        const compatible_category = mapping.compatible[j];\n                        if (compatible_category == null) {\n                            continue;\n                        }\n                        const class_id = this.invoke_definition_map.lookup(compatible_category); // Default Category\n                        if (class_id == null) {\n                            continue;\n                        }\n                        const class_id_bit = 1 << class_id;\n                        bitset = bitset | class_id_bit; // Set a bit of class ID 例えば、class_idが3のとき、3ビット目に1を立てる\n                        this.compatible_category_map[code_point] = bitset;\n                    }\n                }\n            }\n        }\n        const default_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n        if (default_id == null) {\n            return;\n        }\n        const ccm_length = this.compatible_category_map.length;\n        for (code_point = 0; code_point < ccm_length; code_point++) {\n            // 他に何のクラスも定義されていなかったときだけ DEFAULT\n            if (this.character_category_map[code_point] === 0) {\n                // DEFAULT class ID に対応するビットだけ1を立てる\n                this.character_category_map[code_point] = 1 << default_id;\n            }\n        }\n    }\n\n    /**\n     * Lookup compatible categories for a character (not included 1st category)\n     * @param {string} ch UCS2 character (just 1st character is effective)\n     * @returns {Array.<CharacterClass>} character classes\n     */\n    lookupCompatibleCategory(ch: string) {\n        const classes: CharacterClass[] = [];\n        if (!this.invoke_definition_map) {\n            throw new Error(\"CharacterDefinition.lookupCompatibleCategory: invoke_definition_map is null\");\n        }\n        /*\n        if (SurrogateAwareString.isSurrogatePair(ch)) {\n        // Surrogate pair character codes can not be defined by char.def\n        return classes;\n        }\n        */\n        const code = ch.charCodeAt(0);\n        let integer: number | null = null;\n        if (code < this.compatible_category_map.length) {\n            integer = this.compatible_category_map[code]; // Bitset\n        }\n        if (integer == null || integer === 0) {\n            return classes;\n        }\n        for (let bit = 0; bit < 32; bit++) {\n            // Treat \"bit\" as a class ID\n            if ((integer << (31 - bit)) >>> 31 === 1) {\n                const character_class = this.invoke_definition_map.getCharacterClass(bit);\n                if (character_class == null) {\n                    continue;\n                }\n                classes.push(character_class);\n            }\n        }\n        return classes;\n    }\n\n    /**\n     * Lookup category for a character\n     * @param {string} ch UCS2 character (just 1st character is effective)\n     * @returns {CharacterClass} character class\n     */\n    lookup(ch: string) {\n        if (!this.invoke_definition_map) {\n            throw new Error(\"CharacterDefinition.lookup: invoke_definition_map is null\");\n        }\n        let class_id: number | null = null;\n        const code = ch.charCodeAt(0);\n        if (SurrogateAwareString.isSurrogatePair(ch)) {\n            // Surrogate pair character codes can not be defined by char.def, so set DEFAULT category\n            class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n        } else if (code < this.character_category_map.length) {\n            class_id = this.character_category_map[code]; // Read as integer value\n        }\n\n        if (class_id == null) {\n            class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n        }\n\n        return this.invoke_definition_map.getCharacterClass(class_id as number);\n    }\n}\n\nexport default CharacterDefinition;\n",
    "import CharacterDefinition from \"./CharacterDefinition\";\nimport TokenInfoDictionary from \"./TokenInfoDictionary\";\n\nclass UnknownDictionary extends TokenInfoDictionary {\n    #character_definition: CharacterDefinition | null = null;\n\n    characterDefinition(character_definition: CharacterDefinition) {\n        this.#character_definition = character_definition;\n        return this;\n    }\n\n    lookup(ch: string) {\n        if (this.#character_definition == null) {\n            throw new Error(\"CharacterDefinition is not set\");\n        }\n        return this.#character_definition.lookup(ch);\n    }\n\n    lookupCompatibleCategory(ch: string) {\n        if (this.#character_definition == null) {\n            throw new Error(\"CharacterDefinition is not set\");\n        }\n        return this.#character_definition.lookupCompatibleCategory(ch);\n    }\n\n    loadUnknownDictionaries(\n        unk_buffer: Uint8Array,\n        unk_pos_buffer: Uint8Array,\n        unk_map_buffer: Uint8Array,\n        cat_map_buffer: Uint8Array,\n        compat_cat_map_buffer: Uint32Array,\n        invoke_def_buffer: Uint8Array\n    ) {\n        this.loadDictionary(unk_buffer);\n        this.loadPosVector(unk_pos_buffer);\n        this.loadTargetMap(unk_map_buffer);\n        this.#character_definition = new CharacterDefinition().load(\n            cat_map_buffer,\n            compat_cat_map_buffer,\n            invoke_def_buffer\n        );\n    }\n}\n\nexport default UnknownDictionary;\n",
    "import doublearray from \"../../_core/util/DoubleArray\";\nimport type { DoubleArray } from \"../../_core/util/DoubleArray\";\nimport ConnectionCosts from \"./ConnectionCosts\";\nimport TokenInfoDictionary from \"./TokenInfoDictionary\";\nimport UnknownDictionary from \"./UnknownDictionary\";\n\nclass DynamicDictionaries {\n    trie: DoubleArray;\n    token_info_dictionary: TokenInfoDictionary;\n    connection_costs: ConnectionCosts;\n    unknown_dictionary: UnknownDictionary;\n    constructor(\n        trie?: DoubleArray,\n        token_info_dictionary?: TokenInfoDictionary,\n        connection_costs?: ConnectionCosts,\n        unknown_dictionary?: UnknownDictionary\n    ) {\n        this.trie = trie ?? doublearray.builder(0).build([{ k: \"\", v: 1 }]);\n        this.token_info_dictionary = token_info_dictionary ?? new TokenInfoDictionary();\n        // backward_size * backward_size\n        this.connection_costs = connection_costs ?? new ConnectionCosts(0, 0);\n        this.unknown_dictionary = unknown_dictionary ?? new UnknownDictionary();\n    }\n\n    loadTrie(base_buffer: Int32Array, check_buffer: Int32Array) {\n        this.trie = doublearray.load(base_buffer, check_buffer);\n        return this;\n    }\n\n    loadTokenInfoDictionaries(token_info_buffer: Uint8Array, pos_buffer: Uint8Array, target_map_buffer: Uint8Array) {\n        this.token_info_dictionary.loadDictionary(token_info_buffer);\n        this.token_info_dictionary.loadPosVector(pos_buffer);\n        this.token_info_dictionary.loadTargetMap(target_map_buffer);\n        return this;\n    }\n\n    loadConnectionCosts(cc_buffer: Int16Array) {\n        this.connection_costs.loadConnectionCosts(cc_buffer);\n        return this;\n    }\n\n    loadUnknownDictionaries(\n        unk_buffer: Uint8Array,\n        unk_pos_buffer: Uint8Array,\n        unk_map_buffer: Uint8Array,\n        cat_map_buffer: Uint8Array,\n        compat_cat_map_buffer: Uint32Array,\n        invoke_def_buffer: Uint8Array\n    ) {\n        this.unknown_dictionary.loadUnknownDictionaries(\n            unk_buffer,\n            unk_pos_buffer,\n            unk_map_buffer,\n            cat_map_buffer,\n            compat_cat_map_buffer,\n            invoke_def_buffer\n        );\n        return this;\n    }\n}\n\nexport default DynamicDictionaries;\n",
    "import type CharacterClass from \"../CharacterClass\";\nimport CharacterDefinition from \"../CharacterDefinition\";\nimport InvokeDefinitionMap from \"../InvokeDefinitionMap\";\n\nconst CATEGORY_DEF_PATTERN = /^(\\w+)\\s+(\\d)\\s+(\\d)\\s+(\\d)/;\nconst CATEGORY_MAPPING_PATTERN = /^(0x[0-9A-F]{4})(?:\\s+([^#\\s]+))(?:\\s+([^#\\s]+))*/;\nconst RANGE_CATEGORY_MAPPING_PATTERN = /^(0x[0-9A-F]{4})\\.\\.(0x[0-9A-F]{4})(?:\\s+([^#\\s]+))(?:\\s+([^#\\s]+))*/;\n\nclass CharacterDefinitionBuilder {\n    char_def: CharacterDefinition;\n    character_category_definition: CharacterClass[];\n    category_mapping: {\n        start: number;\n        default: string;\n        compatible: string[];\n        end?: number;\n    }[];\n    /**\n     * CharacterDefinitionBuilder\n     * @constructor\n     */\n    constructor() {\n        this.char_def = new CharacterDefinition();\n        this.char_def.invoke_definition_map = new InvokeDefinitionMap();\n        this.character_category_definition = [];\n        this.category_mapping = [];\n    }\n\n    putLine(line: string) {\n        const parsed_category_def = CATEGORY_DEF_PATTERN.exec(line);\n        if (parsed_category_def != null) {\n            const class_id = this.character_category_definition.length;\n            const char_class = CharacterDefinition.parseCharCategory(class_id, parsed_category_def);\n            if (char_class == null) {\n                return;\n            }\n            this.character_category_definition.push(char_class);\n            return;\n        }\n        const parsed_category_mapping = CATEGORY_MAPPING_PATTERN.exec(line);\n        if (parsed_category_mapping != null) {\n            const mapping = CharacterDefinition.parseCategoryMapping(parsed_category_mapping);\n            this.category_mapping.push(mapping);\n        }\n        const parsed_range_category_mapping = RANGE_CATEGORY_MAPPING_PATTERN.exec(line);\n        if (parsed_range_category_mapping != null) {\n            const range_mapping = CharacterDefinition.parseRangeCategoryMapping(parsed_range_category_mapping);\n            this.category_mapping.push(range_mapping);\n        }\n    }\n\n    build() {\n        // TODO If DEFAULT category does not exist, throw error\n        if (!this.char_def || !this.char_def.invoke_definition_map) {\n            throw new Error(\"No data to build.\");\n        }\n        this.char_def.invoke_definition_map.init(this.character_category_definition);\n        this.char_def.initCategoryMappings(this.category_mapping);\n        return this.char_def;\n    }\n}\n\nexport default CharacterDefinitionBuilder;\n",
    "import ConnectionCosts from \"../ConnectionCosts\";\n\nclass ConnectionCostsBuilder {\n    lines: number;\n    connection_cost: null | ConnectionCosts;\n    /**\n     * Builder class for constructing ConnectionCosts object\n     * @constructor\n     */\n    constructor() {\n        this.lines = 0;\n        this.connection_cost = null;\n    }\n\n    putLine(line: string) {\n        if (this.lines === 0 || !this.connection_cost) {\n            const dimensions = line.split(\" \");\n            const forward_dimension = Number.parseInt(dimensions[0]);\n            const backward_dimension = Number.parseInt(dimensions[1]);\n\n            if (forward_dimension < 0 || backward_dimension < 0) {\n                throw \"Parse error of matrix.def\";\n            }\n\n            this.connection_cost = new ConnectionCosts(forward_dimension, backward_dimension);\n            this.lines++;\n            return this;\n        }\n        if (!this.connection_cost) {\n            throw \"connection_cost is null\";\n        }\n\n        const costs = line.split(\" \");\n\n        if (costs.length !== 3) {\n            return this;\n        }\n\n        const forward_id = Number.parseInt(costs[0]);\n        const backward_id = Number.parseInt(costs[1]);\n        const cost = Number.parseInt(costs[2]);\n\n        if (\n            forward_id < 0 ||\n            backward_id < 0 ||\n            !Number.isFinite(forward_id) ||\n            !Number.isFinite(backward_id) ||\n            this.connection_cost.forward_dimension <= forward_id ||\n            this.connection_cost.backward_dimension <= backward_id\n        ) {\n            throw \"Parse error of matrix.def\";\n        }\n\n        this.connection_cost.put(forward_id, backward_id, cost);\n        this.lines++;\n        return this;\n    }\n\n    build() {\n        if (!this.connection_cost) {\n            throw \"No data to build.\";\n        }\n        return this.connection_cost;\n    }\n}\n\nexport default ConnectionCostsBuilder;\n",
    "import doublearray from \"../../../_core/util/DoubleArray\";\nimport DynamicDictionaries from \"../DynamicDictionaries\";\nimport TokenInfoDictionary from \"../TokenInfoDictionary\";\nimport UnknownDictionary from \"../UnknownDictionary\";\nimport CharacterDefinitionBuilder from \"./CharacterDefinitionBuilder\";\nimport ConnectionCostsBuilder from \"./ConnectionCostsBuilder\";\n\nclass DictionaryBuilder {\n    #tid_entries: string[][];\n    #unk_entries: string[][];\n    #cc_builder: ConnectionCostsBuilder;\n    #cd_builder: CharacterDefinitionBuilder;\n    /**\n     * Build dictionaries (token info, connection costs)\n     *\n     * Generates from matrix.def\n     * cc.dat: Connection costs\n     *\n     * Generates from *.csv\n     * dat.dat: Double array\n     * tid.dat: Token info dictionary\n     * tid_map.dat: targetMap\n     * tid_pos.dat: posList (part of speech)\n     */\n    constructor() {\n        // Array of entries, each entry in Mecab form\n        // (0: surface form, 1: left id, 2: right id, 3: word cost, 4: part of speech id, 5-: other features)\n        this.#tid_entries = [];\n        this.#unk_entries = [];\n        this.#cc_builder = new ConnectionCostsBuilder();\n        this.#cd_builder = new CharacterDefinitionBuilder();\n    }\n\n    addTokenInfoDictionary(line: string) {\n        const new_entry = line.split(\",\");\n        this.#tid_entries.push(new_entry);\n        return this;\n    }\n\n    /**\n     * Put one line of \"matrix.def\" file for building ConnectionCosts object\n     * @param {string} line is a line of \"matrix.def\"\n     */\n    putCostMatrixLine(line: string) {\n        this.#cc_builder.putLine(line);\n        return this;\n    }\n\n    putCharDefLine(line: string) {\n        this.#cd_builder.putLine(line);\n        return this;\n    }\n\n    /**\n     * Put one line of \"unk.def\" file for building UnknownDictionary object\n     * @param {string} line is a line of \"unk.def\"\n     */\n    putUnkDefLine(line: string) {\n        this.#unk_entries.push(line.split(\",\"));\n        return this;\n    }\n\n    build() {\n        const dictionaries = this.buildTokenInfoDictionary();\n\n        return new DynamicDictionaries(\n            dictionaries.trie,\n            dictionaries.token_info_dictionary,\n            this.#cc_builder.build(),\n            this.buildUnknownDictionary()\n        );\n    }\n\n    /**\n     * Build TokenInfoDictionary\n     *\n     * @returns {{trie: *, token_info_dictionary: *}}\n     */\n    buildTokenInfoDictionary() {\n        const token_info_dictionary = new TokenInfoDictionary();\n        // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n        const dictionary_entries = token_info_dictionary.buildDictionary(this.#tid_entries);\n        const trie = this.buildDoubleArray();\n        for (const token_info_id in dictionary_entries) {\n            const surface_form = dictionary_entries[token_info_id];\n            const trie_id = trie.lookup(surface_form);\n            // Assertion\n            // if (trie_id < 0) {\n            //     console.log(\"Not Found:\" + surface_form);\n            // }\n            token_info_dictionary.addMapping(trie_id, Number.parseInt(token_info_id));\n        }\n        return {\n            trie: trie,\n            token_info_dictionary: token_info_dictionary,\n        };\n    }\n\n    buildUnknownDictionary() {\n        const unk_dictionary = new UnknownDictionary();\n        // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n        const dictionary_entries = unk_dictionary.buildDictionary(this.#unk_entries);\n        const char_def = this.#cd_builder.build(); // Create CharacterDefinition\n        if (!char_def || !char_def.invoke_definition_map) {\n            throw new Error(\"CharacterDefinition is not set\");\n        }\n        unk_dictionary.characterDefinition(char_def);\n        for (const token_info_id in dictionary_entries) {\n            const class_name = dictionary_entries[token_info_id];\n            const class_id = char_def.invoke_definition_map.lookup(class_name);\n            if (!class_id) {\n                throw new Error(`Class name not found: ${class_name}`);\n            }\n            // Assertion\n            // if (trie_id < 0) {\n            //     console.log(\"Not Found:\" + surface_form);\n            // }\n            unk_dictionary.addMapping(class_id, Number.parseInt(token_info_id));\n        }\n        return unk_dictionary;\n    }\n\n    /**\n     * Build double array trie\n     *\n     * @returns {DoubleArray} Double-Array trie\n     */\n    buildDoubleArray() {\n        let trie_id = 0;\n        const words = this.#tid_entries.map((entry) => {\n            const surface_form = entry[0];\n            return { k: surface_form, v: trie_id++ };\n        });\n\n        const builder = doublearray.builder(1024 * 1024);\n        return builder.build(words);\n    }\n}\n\nexport default DictionaryBuilder;\n",
    "import type { WORD_TYPE } from \"../viterbi/ViterbiNode\";\n\nexport type TOKEN = {\n    word_id: number;\n    word_type: WORD_TYPE;\n    word_position: number;\n    surface_form: string | Uint8Array;\n    pos: string;\n    pos_detail_1: string;\n    pos_detail_2: string;\n    pos_detail_3: string;\n    conjugated_type: string;\n    conjugated_form: string;\n    basic_form: string;\n    reading?: string;\n    pronunciation?: string;\n};\n\n/**\n * Mappings between IPADIC dictionary features and tokenized results\n * @constructor\n */\nclass IpadicFormatter {\n    formatEntry(word_id: number, position: number, type: WORD_TYPE, features: string[]): TOKEN {\n        return {\n            word_id: word_id,\n            word_type: type,\n            word_position: position,\n            surface_form: features[0],\n            pos: features[1],\n            pos_detail_1: features[2],\n            pos_detail_2: features[3],\n            pos_detail_3: features[4],\n            conjugated_type: features[5],\n            conjugated_form: features[6],\n            basic_form: features[7],\n            reading: features[8],\n            pronunciation: features[9],\n        };\n    }\n\n    formatUnknownEntry(\n        word_id: number,\n        position: number,\n        type: WORD_TYPE,\n        features: string[],\n        surface_form: string | Uint8Array\n    ): TOKEN {\n        return {\n            word_id: word_id,\n            word_type: type,\n            word_position: position,\n            surface_form: surface_form,\n            pos: features[1],\n            pos_detail_1: features[2],\n            pos_detail_2: features[3],\n            pos_detail_3: features[4],\n            conjugated_type: features[5],\n            conjugated_form: features[6],\n            basic_form: features[7],\n            // token.reading = features[8];\n            // token.pronunciation = features[9];\n        };\n    }\n}\n\nexport default IpadicFormatter;\n",
    "export type WORD_TYPE = \"KNOWN\" | \"UNKNOWN\" | \"BOS\" | \"EOS\";\n\nclass ViterbiNode {\n    name: number;\n    cost: number;\n    start_pos: number;\n    length: number;\n    left_id: number;\n    right_id: number;\n    prev: null | ViterbiNode;\n    surface_form: string | Uint8Array;\n    shortest_cost: number;\n    type: WORD_TYPE;\n\n    /**\n     * ViterbiNode is a node of ViterbiLattice\n     * @param {number} node_name Word ID\n     * @param {number} node_cost Word cost to generate\n     * @param {number} start_pos Start position from 1\n     * @param {number} length Word length\n     * @param {string} type Node type (KNOWN, UNKNOWN, BOS, EOS, ...)\n     * @param {number} left_id Left context ID\n     * @param {number} right_id Right context ID\n     * @param {string} surface_form Surface form of this word\n     * @constructor\n     */\n    constructor(\n        node_name: number,\n        node_cost: number,\n        start_pos: number,\n        length: number,\n        type: WORD_TYPE,\n        left_id: number,\n        right_id: number,\n        surface_form: string | Uint8Array\n    ) {\n        this.name = node_name;\n        this.cost = node_cost;\n        this.start_pos = start_pos;\n        this.length = length;\n        this.left_id = left_id;\n        this.right_id = right_id;\n        this.prev = null;\n        this.surface_form = surface_form;\n        this.shortest_cost = type === \"BOS\" ? 0 : Number.MAX_VALUE;\n        this.type = type;\n    }\n}\n\nexport default ViterbiNode;\n",
    "import ViterbiNode from \"./ViterbiNode\";\n\nclass ViterbiLattice {\n    nodes_end_at: ViterbiNode[][];\n    eos_pos: number;\n    /**\n     * ViterbiLattice is a lattice in Viterbi algorithm\n     * @constructor\n     */\n    constructor() {\n        this.nodes_end_at = [];\n        this.nodes_end_at[0] = [new ViterbiNode(-1, 0, 0, 0, \"BOS\", 0, 0, \"\")];\n        this.eos_pos = 1;\n    }\n\n    /**\n     * Append node to ViterbiLattice\n     * @param {ViterbiNode} node\n     */\n    append(node: ViterbiNode) {\n        const last_pos = node.start_pos + node.length - 1;\n        if (this.eos_pos < last_pos) {\n            this.eos_pos = last_pos;\n        }\n\n        const prev_nodes = this.nodes_end_at[last_pos] ?? [];\n        prev_nodes.push(node);\n\n        this.nodes_end_at[last_pos] = prev_nodes;\n    }\n\n    /**\n     * Set ends with EOS (End of Statement)\n     */\n    appendEos() {\n        const last_index = this.nodes_end_at.length;\n        this.eos_pos++;\n        this.nodes_end_at[last_index] = [new ViterbiNode(-1, 0, this.eos_pos, 0, \"EOS\", 0, 0, \"\")];\n    }\n}\n\nexport default ViterbiLattice;\n",
    "import type DynamicDictionaries from \"../dict/DynamicDictionaries\";\nimport type TokenInfoDictionary from \"../dict/TokenInfoDictionary\";\nimport type UnknownDictionary from \"../dict/UnknownDictionary\";\nimport type { DoubleArray } from \"../util/DoubleArray\";\nimport SurrogateAwareString from \"../util/SurrogateAwareString\";\nimport ViterbiLattice from \"./ViterbiLattice\";\nimport ViterbiNode from \"./ViterbiNode\";\n\nclass ViterbiBuilder {\n    #trie: DoubleArray;\n    #token_info_dictionary: TokenInfoDictionary;\n    #unknown_dictionary: UnknownDictionary;\n    /**\n     * ViterbiBuilder builds word lattice (ViterbiLattice)\n     * @param {DynamicDictionaries} dic dictionary\n     * @constructor\n     */\n    constructor(dic: DynamicDictionaries) {\n        this.#trie = dic.trie;\n        this.#token_info_dictionary = dic.token_info_dictionary;\n        this.#unknown_dictionary = dic.unknown_dictionary;\n    }\n\n    /**\n     * Build word lattice\n     * @param {string} sentence_str Input text\n     * @returns {ViterbiLattice} Word lattice\n     */\n    build(sentence_str: string) {\n        const lattice = new ViterbiLattice();\n        const sentence = new SurrogateAwareString(sentence_str);\n        const sentence_length = sentence.length;\n        for (let pos = 0; pos < sentence_length; pos++) {\n            const tail = sentence.slice(pos);\n            const vocabulary = this.#trie.commonPrefixSearch(tail);\n            const vocabulary_length = vocabulary.length;\n            for (let n = 0; n < vocabulary_length; n++) {\n                // Words in dictionary do not have surrogate pair (only UCS2 set)\n                const trie_id = vocabulary[n].v;\n                const key = vocabulary[n].k;\n                const token_info_ids = this.#token_info_dictionary.target_map.get(trie_id);\n                if (!token_info_ids) throw new Error(\"TokenInfo dictionary is broken\");\n                for (const token_info_id of token_info_ids) {\n                    const left_id = this.#token_info_dictionary.dictionary.getShort(token_info_id);\n                    const right_id = this.#token_info_dictionary.dictionary.getShort(token_info_id + 2);\n                    const word_cost = this.#token_info_dictionary.dictionary.getShort(token_info_id + 4);\n                    // node_name, cost, start_index, length, type, left_id, right_id, surface_form\n                    lattice.append(\n                        new ViterbiNode(token_info_id, word_cost, pos + 1, key.length, \"KNOWN\", left_id, right_id, key)\n                    );\n                }\n            }\n\n            const head_char = tail.charAt(0);\n            const head_char_class = this.#unknown_dictionary.lookup(head_char);\n            if (!vocabulary?.length || head_char_class.is_always_invoke) {\n                let key = head_char;\n                const tail_length = tail.length;\n                if (head_char_class.is_grouping && tail_length > 1) {\n                    const class_name = head_char_class.class_name;\n                    for (let k = 1; k < tail_length; k++) {\n                        const next_char = tail.charAt(k);\n                        if (this.#unknown_dictionary.lookup(next_char).class_name !== class_name) {\n                            break;\n                        }\n                        key += next_char;\n                    }\n                }\n                const unk_ids = this.#unknown_dictionary.target_map.get(head_char_class.class_id);\n                if (!unk_ids) throw new Error(\"Unknown dictionary is broken\");\n                const unk_length = unk_ids.length;\n                const unknown_dict = this.#unknown_dictionary.dictionary;\n                for (let j = 0; j < unk_length; j++) {\n                    const unk_id = unk_ids[j];\n                    lattice.append(\n                        new ViterbiNode(\n                            unk_id,\n                            unknown_dict.getShort(unk_id + 4),\n                            pos + 1,\n                            key.length,\n                            \"UNKNOWN\",\n                            unknown_dict.getShort(unk_id),\n                            unknown_dict.getShort(unk_id + 2),\n                            key\n                        )\n                    );\n                }\n            }\n        }\n\n        lattice.appendEos();\n\n        return lattice;\n    }\n}\n\nexport default ViterbiBuilder;\n",
    "import type ConnectionCosts from \"../dict/ConnectionCosts\";\nimport type ViterbiLattice from \"./ViterbiLattice\";\nimport type ViterbiNode from \"./ViterbiNode\";\n\nclass ViterbiSearcher {\n    #connection_costs: ConnectionCosts;\n    /**\n     * ViterbiSearcher is for searching best Viterbi path\n     * @param {ConnectionCosts} connection_costs Connection costs matrix\n     * @constructor\n     */\n    constructor(connection_costs: ConnectionCosts) {\n        this.#connection_costs = connection_costs;\n    }\n\n    /**\n     * Search best path by forward-backward algorithm\n     * @param {ViterbiLattice} lattice Viterbi lattice to search\n     * @returns {Array} Shortest path\n     */\n    search(_lattice: ViterbiLattice) {\n        let lattice = _lattice;\n        lattice = this.#forward(lattice);\n        return this.#backward(lattice);\n    }\n\n    #forward(lattice: ViterbiLattice) {\n        let i = 1;\n        for (i = 1; i <= lattice.eos_pos; i++) {\n            const nodes = lattice.nodes_end_at[i];\n            if (nodes == null) continue;\n            for (const node of nodes) {\n                let cost = Number.MAX_VALUE;\n                let shortest_prev_node: ViterbiNode | null = null;\n                const index = node.start_pos - 1;\n                if (!(index in lattice.nodes_end_at)) {\n                    // TODO process unknown words (repair word lattice)\n                    continue;\n                }\n                const prev_nodes = lattice.nodes_end_at[index];\n                for (const prev_node of prev_nodes) {\n                    let edge_cost: number;\n                    if (node.left_id == null || prev_node.right_id == null) {\n                        // TODO assert\n                        console.log(\"Left or right is null\");\n                        edge_cost = 0;\n                    } else {\n                        edge_cost = this.#connection_costs.get(prev_node.right_id, node.left_id);\n                    }\n                    const _cost = prev_node.shortest_cost + edge_cost + node.cost;\n                    if (_cost < cost) {\n                        shortest_prev_node = prev_node;\n                        cost = _cost;\n                    }\n                }\n                node.prev = shortest_prev_node;\n                node.shortest_cost = cost;\n            }\n        }\n        return lattice;\n    }\n\n    #backward(lattice: ViterbiLattice) {\n        const shortest_path: ViterbiNode[] = [];\n        const eos = lattice.nodes_end_at[lattice.nodes_end_at.length - 1][0];\n        let node_back = eos.prev;\n        if (node_back == null) {\n            return [];\n        }\n        while (node_back.type !== \"BOS\") {\n            shortest_path.push(node_back);\n            if (node_back.prev == null) {\n                // TODO Failed to back. Process unknown words?\n                return [];\n            }\n            node_back = node_back.prev;\n        }\n\n        return shortest_path.reverse();\n    }\n}\n\nexport default ViterbiSearcher;\n",
    "import type DynamicDictionaries from \"./dict/DynamicDictionaries\";\nimport type TokenInfoDictionary from \"./dict/TokenInfoDictionary\";\nimport type UnknownDictionary from \"./dict/UnknownDictionary\";\nimport IpadicFormatter, { type TOKEN } from \"./util/IpadicFormatter\";\nimport ViterbiBuilder from \"./viterbi/ViterbiBuilder\";\nimport type ViterbiNode from \"./viterbi/ViterbiNode\";\nimport ViterbiSearcher from \"./viterbi/ViterbiSearcher\";\n\nclass Tokenizer {\n    #token_info_dictionary: TokenInfoDictionary;\n    #unknown_dictionary: UnknownDictionary;\n    #viterbi_builder: ViterbiBuilder;\n    #viterbi_searcher: ViterbiSearcher;\n    #formatter: IpadicFormatter;\n    constructor(dic: DynamicDictionaries) {\n        this.#token_info_dictionary = dic.token_info_dictionary;\n        this.#unknown_dictionary = dic.unknown_dictionary;\n        this.#viterbi_builder = new ViterbiBuilder(dic);\n        this.#viterbi_searcher = new ViterbiSearcher(dic.connection_costs);\n        this.#formatter = new IpadicFormatter(); // TODO Other dictionaries\n    }\n\n    static splitByPunctuation(input: string): string[] {\n        const matches = input.matchAll(/、|。/g);\n        const sentences = [];\n        let lastIndex = 0;\n        for (const match of matches) {\n            const index = match.index;\n            sentences.push(input.slice(lastIndex, index + 1));\n            lastIndex = index + 1;\n        }\n        if (lastIndex < input.length) {\n            sentences.push(input.slice(lastIndex));\n        }\n        return sentences;\n    }\n\n    tokenize(text: string) {\n        const sentences = Tokenizer.splitByPunctuation(text);\n        const tokens: TOKEN[] = [];\n        for (const sentence of sentences) {\n            this.#tokenizeForSentence(sentence, tokens);\n        }\n        return tokens;\n    }\n\n    #tokenizeForSentence(sentence: string, tokens: TOKEN[] = []): TOKEN[] {\n        const lattice = this.#viterbi_builder.build(sentence);\n        const best_path = this.#viterbi_searcher.search(lattice);\n        const last_pos = tokens.length > 0 ? tokens[tokens.length - 1].word_position : 0;\n        for (const node of best_path) {\n            tokens.push(this.#getTokenFromNode(node, last_pos));\n        }\n        return tokens;\n    }\n\n    #getTokenFromNode(node: ViterbiNode, last_pos: number): TOKEN {\n        const features_line =\n            node.type === \"KNOWN\"\n                ? this.#token_info_dictionary.getFeatures(node.name)\n                : this.#unknown_dictionary.getFeatures(node.name);\n\n        const features = features_line ? features_line.split(\",\") : [];\n\n        if (node.type === \"UNKNOWN\") {\n            return this.#formatter.formatUnknownEntry(\n                node.name,\n                last_pos + node.start_pos,\n                node.type,\n                features,\n                node.surface_form\n            );\n        }\n\n        return this.#formatter.formatEntry(node.name, last_pos + node.start_pos, node.type, features);\n    }\n}\n\nexport default Tokenizer;\n",
    "import { existsSync, readFileSync } from \"node:fs\";\nimport path from \"node:path\";\nimport zlib from \"node:zlib\";\nimport DynamicDictionaries from \"../../_core/dict/DynamicDictionaries\";\n\nclass DictionaryLoader {\n    #dic: DynamicDictionaries;\n    #dic_path: string;\n    constructor(dic_path = \"dict/\") {\n        this.#dic = new DynamicDictionaries();\n        this.#dic_path = dic_path;\n    }\n\n    #loadArrayBuffer = (file: string) =>\n        new Promise<ArrayBufferLike>((resolve, reject) => {\n            if (!existsSync(file)) return reject(new Error(`${file} does not exist`));\n            const buffer = readFileSync(file);\n            zlib.gunzip(new Uint8Array(buffer), (err, binary) => {\n                if (err) return reject(err);\n                const typed_array = new Uint8Array(binary);\n                resolve(typed_array.buffer);\n            });\n        });\n\n    load = () =>\n        new Promise<DynamicDictionaries>((resolve, reject) => {\n            Promise.all(\n                [\n                    // Trie\n                    \"base.dat.gz\",\n                    \"check.dat.gz\",\n                    // Token info dictionaries\n                    \"tid.dat.gz\",\n                    \"tid_pos.dat.gz\",\n                    \"tid_map.dat.gz\",\n                    // Connection cost matrix\n                    \"cc.dat.gz\",\n                    // Unknown dictionaries\n                    \"unk.dat.gz\",\n                    \"unk_pos.dat.gz\",\n                    \"unk_map.dat.gz\",\n                    \"unk_char.dat.gz\",\n                    \"unk_compat.dat.gz\",\n                    \"unk_invoke.dat.gz\",\n                ].map((filename) => this.#loadArrayBuffer(path.join(this.#dic_path, filename)))\n            )\n                .then((buffers) => {\n                    // Trie\n                    this.#dic.loadTrie(new Int32Array(buffers[0]), new Int32Array(buffers[1]));\n                    // Token info dictionaries\n                    this.#dic.loadTokenInfoDictionaries(\n                        new Uint8Array(buffers[2]),\n                        new Uint8Array(buffers[3]),\n                        new Uint8Array(buffers[4])\n                    );\n                    // Connection cost matrix\n                    this.#dic.loadConnectionCosts(new Int16Array(buffers[5]));\n                    // Unknown dictionaries\n                    this.#dic.loadUnknownDictionaries(\n                        new Uint8Array(buffers[6]),\n                        new Uint8Array(buffers[7]),\n                        new Uint8Array(buffers[8]),\n                        new Uint8Array(buffers[9]),\n                        new Uint32Array(buffers[10]),\n                        new Uint8Array(buffers[11])\n                    );\n                    //// this.#dic.loadUnknownDictionaries(char_buffer, unk_buffer);\n                    resolve(this.#dic);\n                })\n                .catch((error) => {\n                    reject(error);\n                });\n        });\n}\n\nexport default DictionaryLoader;\n",
    "import Tokenizer from \"../_core/Tokenizer\";\nimport DictionaryLoader from \"./loader/DictionaryLoader\";\n\nexport type TokenizerBuilderOption = {\n    dicPath?: string | undefined;\n};\n\nclass TokenizerBuilder {\n    #loader: DictionaryLoader;\n\n    constructor(option: TokenizerBuilderOption = {}) {\n        this.#loader = new DictionaryLoader(option.dicPath);\n    }\n\n    async build(): Promise<Tokenizer> {\n        const dictionary = await this.#loader.load();\n        return new Tokenizer(dictionary);\n    }\n}\n\nexport default TokenizerBuilder;\n",
    "import DictionaryBuilder from \"../_core/dict/builder/DictionaryBuilder\";\nimport TokenizerBuilder, { type TokenizerBuilderOption } from \"./TokenizerBuilder\";\n\nexport { TokenizerBuilder, type TokenizerBuilderOption, DictionaryBuilder };\n\n// Public methods\nexport default {\n    builder: (option: TokenizerBuilderOption = {}) => {\n        return new TokenizerBuilder(option);\n    },\n    dictionaryBuilder: () => {\n        return new DictionaryBuilder();\n    },\n};\n"
  ],
  "mappings": "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",
  "debugId": "028013DAE203614C64756E2164756E21",
  "names": []
}